// generated by lelwel 0.4.2

#![allow(non_snake_case)]
#![allow(unused_variables)]

use super::token::*;

// preamble
use super::symbol::Symbol;
use super::ast::*;
use super::diag::*;
use bumpalo::{Bump, collections::Vec as BVec};

#[derive(PartialEq, Clone, Debug)]
pub enum TokenKind {
    EOF,
    Token,
    Language,
    Error,
    Start,
    Preamble,
    Pars,
    Limit,
    Colon,
    Semi,
    Equal,
    LPar,
    RPar,
    LBrak,
    RBrak,
    Or,
    Star,
    Plus,
    Id(Symbol),
    Str(Symbol),
    Code(Symbol),
    Int(u16),
    Predicate(u64),
    Action(u64),
    ErrorHandler(u64),
    _Comment(Symbol),
}

macro_rules! pattern_EOF { () => { TokenKind::EOF } }
macro_rules! pattern_Token { () => { TokenKind::Token } }
macro_rules! pattern_Language { () => { TokenKind::Language } }
macro_rules! pattern_Error { () => { TokenKind::Error } }
macro_rules! pattern_Start { () => { TokenKind::Start } }
macro_rules! pattern_Preamble { () => { TokenKind::Preamble } }
macro_rules! pattern_Pars { () => { TokenKind::Pars } }
macro_rules! pattern_Limit { () => { TokenKind::Limit } }
macro_rules! pattern_Colon { () => { TokenKind::Colon } }
macro_rules! pattern_Semi { () => { TokenKind::Semi } }
macro_rules! pattern_Equal { () => { TokenKind::Equal } }
macro_rules! pattern_LPar { () => { TokenKind::LPar } }
macro_rules! pattern_RPar { () => { TokenKind::RPar } }
macro_rules! pattern_LBrak { () => { TokenKind::LBrak } }
macro_rules! pattern_RBrak { () => { TokenKind::RBrak } }
macro_rules! pattern_Or { () => { TokenKind::Or } }
macro_rules! pattern_Star { () => { TokenKind::Star } }
macro_rules! pattern_Plus { () => { TokenKind::Plus } }
macro_rules! pattern_Id { () => { TokenKind::Id(_) } }
macro_rules! pattern_Str { () => { TokenKind::Str(_) } }
macro_rules! pattern_Code { () => { TokenKind::Code(_) } }
macro_rules! pattern_Int { () => { TokenKind::Int(_) } }
macro_rules! pattern_Predicate { () => { TokenKind::Predicate(_) } }
macro_rules! pattern_Action { () => { TokenKind::Action(_) } }
macro_rules! pattern_ErrorHandler { () => { TokenKind::ErrorHandler(_) } }
macro_rules! pattern__Comment { () => { TokenKind::_Comment(_) } }

macro_rules! default_EOF { () => { TokenKind::EOF } }
macro_rules! default_Token { () => { TokenKind::Token } }
macro_rules! default_Language { () => { TokenKind::Language } }
macro_rules! default_Error { () => { TokenKind::Error } }
macro_rules! default_Start { () => { TokenKind::Start } }
macro_rules! default_Preamble { () => { TokenKind::Preamble } }
macro_rules! default_Pars { () => { TokenKind::Pars } }
macro_rules! default_Limit { () => { TokenKind::Limit } }
macro_rules! default_Colon { () => { TokenKind::Colon } }
macro_rules! default_Semi { () => { TokenKind::Semi } }
macro_rules! default_Equal { () => { TokenKind::Equal } }
macro_rules! default_LPar { () => { TokenKind::LPar } }
macro_rules! default_RPar { () => { TokenKind::RPar } }
macro_rules! default_LBrak { () => { TokenKind::LBrak } }
macro_rules! default_RBrak { () => { TokenKind::RBrak } }
macro_rules! default_Or { () => { TokenKind::Or } }
macro_rules! default_Star { () => { TokenKind::Star } }
macro_rules! default_Plus { () => { TokenKind::Plus } }
macro_rules! default_Id { () => { TokenKind::Id(Symbol::default()) } }
macro_rules! default_Str { () => { TokenKind::Str(Symbol::default()) } }
macro_rules! default_Code { () => { TokenKind::Code(Symbol::default()) } }
macro_rules! default_Int { () => { TokenKind::Int(u16::default()) } }
macro_rules! default_Predicate { () => { TokenKind::Predicate(u64::default()) } }
macro_rules! default_Action { () => { TokenKind::Action(u64::default()) } }
macro_rules! default_ErrorHandler { () => { TokenKind::ErrorHandler(u64::default()) } }

macro_rules! err { [$($tk:expr),*] => { Err(Code::from(vec![$($tk),*])) } }

#[allow(unused_macros)]
macro_rules! check_limit {
    ($input:ident, $depth:expr) => {
        if $depth > 128 {
            $input.finalize();
            return Err(Code::from("exceeded recursion depth limit"));
        }
    }
}

macro_rules! consume_Token {
    ($input:ident) => {
        if let TokenKind::Token = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Token!()]
        }
    }
}
macro_rules! consume_Language {
    ($input:ident) => {
        if let TokenKind::Language = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Language!()]
        }
    }
}
macro_rules! consume_Error {
    ($input:ident) => {
        if let TokenKind::Error = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Error!()]
        }
    }
}
macro_rules! consume_Start {
    ($input:ident) => {
        if let TokenKind::Start = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Start!()]
        }
    }
}
macro_rules! consume_Preamble {
    ($input:ident) => {
        if let TokenKind::Preamble = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Preamble!()]
        }
    }
}
macro_rules! consume_Pars {
    ($input:ident) => {
        if let TokenKind::Pars = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Pars!()]
        }
    }
}
macro_rules! consume_Limit {
    ($input:ident) => {
        if let TokenKind::Limit = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Limit!()]
        }
    }
}
macro_rules! consume_Colon {
    ($input:ident) => {
        if let TokenKind::Colon = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Colon!()]
        }
    }
}
macro_rules! consume_Semi {
    ($input:ident) => {
        if let TokenKind::Semi = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Semi!()]
        }
    }
}
macro_rules! consume_Equal {
    ($input:ident) => {
        if let TokenKind::Equal = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Equal!()]
        }
    }
}
macro_rules! consume_LPar {
    ($input:ident) => {
        if let TokenKind::LPar = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_LPar!()]
        }
    }
}
macro_rules! consume_RPar {
    ($input:ident) => {
        if let TokenKind::RPar = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_RPar!()]
        }
    }
}
macro_rules! consume_LBrak {
    ($input:ident) => {
        if let TokenKind::LBrak = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_LBrak!()]
        }
    }
}
macro_rules! consume_RBrak {
    ($input:ident) => {
        if let TokenKind::RBrak = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_RBrak!()]
        }
    }
}
macro_rules! consume_Or {
    ($input:ident) => {
        if let TokenKind::Or = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Or!()]
        }
    }
}
macro_rules! consume_Star {
    ($input:ident) => {
        if let TokenKind::Star = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Star!()]
        }
    }
}
macro_rules! consume_Plus {
    ($input:ident) => {
        if let TokenKind::Plus = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            range
        } else {
            return err![default_Plus!()]
        }
    }
}
macro_rules! consume_Id {
    ($input:ident) => {
        if let TokenKind::Id(value) = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            (value, range)
        } else {
            return err![default_Id!()]
        }
    }
}
macro_rules! consume_Str {
    ($input:ident) => {
        if let TokenKind::Str(value) = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            (value, range)
        } else {
            return err![default_Str!()]
        }
    }
}
macro_rules! consume_Code {
    ($input:ident) => {
        if let TokenKind::Code(value) = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            (value, range)
        } else {
            return err![default_Code!()]
        }
    }
}
macro_rules! consume_Int {
    ($input:ident) => {
        if let TokenKind::Int(value) = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            (value, range)
        } else {
            return err![default_Int!()]
        }
    }
}
macro_rules! consume_Predicate {
    ($input:ident) => {
        if let TokenKind::Predicate(value) = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            (value, range)
        } else {
            return err![default_Predicate!()]
        }
    }
}
macro_rules! consume_Action {
    ($input:ident) => {
        if let TokenKind::Action(value) = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            (value, range)
        } else {
            return err![default_Action!()]
        }
    }
}
macro_rules! consume_ErrorHandler {
    ($input:ident) => {
        if let TokenKind::ErrorHandler(value) = $input.current().kind {
            let range = $input.current().range;
            $input.advance();
            (value, range)
        } else {
            return err![default_ErrorHandler!()]
        }
    }
}

use std::fmt;
impl fmt::Display for TokenKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            pattern_EOF!() => write!(f, "end of file"),
            pattern_Token!() => write!(f, "{}", r###"token"###),
            pattern_Language!() => write!(f, "{}", r###"language"###),
            pattern_Error!() => write!(f, "{}", r###"error"###),
            pattern_Start!() => write!(f, "{}", r###"start"###),
            pattern_Preamble!() => write!(f, "{}", r###"preamble"###),
            pattern_Pars!() => write!(f, "{}", r###"parameters"###),
            pattern_Limit!() => write!(f, "{}", r###"limit"###),
            pattern_Colon!() => write!(f, "{}", r###":"###),
            pattern_Semi!() => write!(f, "{}", r###";"###),
            pattern_Equal!() => write!(f, "{}", r###"="###),
            pattern_LPar!() => write!(f, "{}", r###"("###),
            pattern_RPar!() => write!(f, "{}", r###")"###),
            pattern_LBrak!() => write!(f, "{}", r###"["###),
            pattern_RBrak!() => write!(f, "{}", r###"]"###),
            pattern_Or!() => write!(f, "{}", r###"|"###),
            pattern_Star!() => write!(f, "{}", r###"*"###),
            pattern_Plus!() => write!(f, "{}", r###"+"###),
            pattern_Id!() => write!(f, "{}", r###"<identifier>"###),
            pattern_Str!() => write!(f, "{}", r###"<string literal>"###),
            pattern_Code!() => write!(f, "{}", r###"<code segment>"###),
            pattern_Int!() => write!(f, "{}", r###"<integer>"###),
            pattern_Predicate!() => write!(f, "{}", r###"<semantic predicate>"###),
            pattern_Action!() => write!(f, "{}", r###"<semantic action>"###),
            pattern_ErrorHandler!() => write!(f, "{}", r###"<error handler>"###),
            pattern__Comment!() => write!(f, "{}", r###"_Comment"###),
        }
    }
}

pub trait Parsing<'a, Input: TokenStream> {
    type Output;

    fn parse(input: &mut Input, arena: &'a Bump, diag: &mut Diag) -> Result<Self::Output, Code>;
}

impl<'a, Input: TokenStream> Parsing<'a, Input> for Parser {
    type Output = Module<'a>;

    fn parse(input: &mut Input, arena: &'a Bump, diag: &mut Diag) -> Result<Self::Output, Code> {
        input.advance();
        let out = Self::start(0, input, arena, diag)?;
        if input.current().kind != TokenKind::EOF {
            return err![default_EOF!()]
        }
        Ok(out)
    }
}

pub struct Parser;

impl<'a> Parser {
    fn start<Input: TokenStream>(depth: u16, input: &mut Input, arena: &'a Bump, diag: &mut Diag) -> Result<Module<'a>, Code> {
        // semantic action 0
        let mut elements = BVec::new_in(arena);
        loop {
            match input.current().kind {
                pattern_Token!()
                | pattern_Language!()
                | pattern_Error!()
                | pattern_Start!()
                | pattern_Preamble!()
                | pattern_Pars!()
                | pattern_Limit!()
                | pattern_Id!() => {
                    (|| {
                        match input.current().kind {
                            pattern_Token!() => {
                                // semantic action 1
                                let elements = &mut elements;
                                let r#tokens = Self::r#tokens(depth + 1, input, arena, diag, elements)?;
                                Ok(())
                            }
                            pattern_Start!()
                            | pattern_Id!() => {
                                let r#rule_or_action = Self::r#rule_or_action(depth + 1, input, arena, diag)?;
                                // semantic action 2
                                elements.push(rule_or_action);
                                Ok(())
                            }
                            pattern_Preamble!() => {
                                let r#Preamble = consume_Preamble!(input);
                                let r#Code = consume_Code!(input);
                                // semantic action 3
                                elements.push(Element::new_preamble(arena, Code.0, Code.1));
                                Ok(())
                            }
                            pattern_Pars!() => {
                                let r#Pars = consume_Pars!(input);
                                let r#Code = consume_Code!(input);
                                // semantic action 4
                                elements.push(Element::new_parameters(arena, Code.0, Code.1));
                                Ok(())
                            }
                            pattern_Language!() => {
                                let r#Language = consume_Language!(input);
                                let r#Id = consume_Id!(input);
                                let r#Semi = consume_Semi!(input);
                                // semantic action 5
                                elements.push(Element::new_language(arena, Id.0, Id.1));
                                Ok(())
                            }
                            pattern_Error!() => {
                                let r#Error = consume_Error!(input);
                                let r#Code = consume_Code!(input);
                                // semantic action 6
                                elements.push(Element::new_error_code(arena, Code.0, Code.1));
                                Ok(())
                            }
                            pattern_Limit!() => {
                                let r#Limit = consume_Limit!(input);
                                let r#Int = consume_Int!(input);
                                let r#Semi = consume_Semi!(input);
                                // semantic action 7
                                elements.push(Element::new_limit(arena, Int.0, Int.1));
                                Ok(())
                            }
                            _ => {
                                return err![default_Token!(),
                                            default_Language!(),
                                            default_Error!(),
                                            default_Start!(),
                                            default_Preamble!(),
                                            default_Pars!(),
                                            default_Limit!(),
                                            default_Id!()]
                            }
                        }
                    })().or_else(|error_code| {
                        // error handling
                        if input.current().kind == TokenKind::EOF {
                            return Err(error_code);
                        }
                        let error_range = input.current().range;
                        loop {
                            match input.current().kind {
                                pattern_EOF!()
                                | pattern_Token!()
                                | pattern_Language!()
                                | pattern_Error!()
                                | pattern_Start!()
                                | pattern_Preamble!()
                                | pattern_Pars!()
                                | pattern_Limit!()
                                | pattern_Id!() => {
                                    // error handler 1
                                    diag.error(error_code, error_range);
                                    elements.push(Element::new_invalid(arena, error_range));
                                    return Ok(())
                                }
                                _ => {
                                    input.advance();
                                }
                           }
                       }
                    })?;
                }
                pattern_EOF!() => break,
                _ => {
                    return err![default_EOF!(),
                                default_Token!(),
                                default_Language!(),
                                default_Error!(),
                                default_Start!(),
                                default_Preamble!(),
                                default_Pars!(),
                                default_Limit!(),
                                default_Id!()]
                }
            }
        }
        // semantic action 8
        Ok(Module::new(elements))
    }
    fn r#tokens<Input: TokenStream>(depth: u16, input: &mut Input, arena: &'a Bump, diag: &mut Diag, elements: &mut BVec<'a, &'a Element<'a>>) -> Result<(), Code> {
        check_limit!(input, depth);
        // semantic action 0
        let trivia = input.trivia();
        let r#Token = consume_Token!(input);
        let mut is_first = true;
        loop {
            match input.current().kind {
                pattern_Id!() => {
                    (|| {
                        let r#Id = consume_Id!(input);
                        // semantic action 1
                        let mut range = Id.1;
                        let mut ty = Symbol::default();
                        let mut sym = Symbol::default();
                        match input.current().kind {
                            pattern_Code!() => {
                                let r#Code = consume_Code!(input);
                                // semantic action 2
                                ty = Code.0;
                                range = Range::span(range, Code.1);
                            }
                            pattern_Semi!()
                            | pattern_Equal!()
                            | pattern_Id!() => {}
                            _ => {
                                return err![default_Semi!(),
                                            default_Equal!(),
                                            default_Id!(),
                                            default_Code!()]
                            }
                        }
                        match input.current().kind {
                            pattern_Equal!() => {
                                let r#Equal = consume_Equal!(input);
                                let r#Str = consume_Str!(input);
                                // semantic action 3
                                sym = Str.0;
                                range = Range::span(range, Str.1);
                            }
                            pattern_Semi!()
                            | pattern_Id!() => {}
                            _ => {
                                return err![default_Semi!(),
                                            default_Equal!(),
                                            default_Id!()]
                            }
                        }
                        // semantic action 4
                        elements.push(Element::new_token(arena, Id.0, ty, sym, range, trivia.clone()));
                        match input.current().kind {
                            pattern_Semi!()
                            | pattern_Id!() => {
                                Ok(())
                            }
                            _ => {
                                return err![default_Semi!(),
                                            default_Id!()]
                            }
                        }
                    })().or_else(|error_code| {
                        // error handling
                        if input.current().kind == TokenKind::EOF {
                            return Err(error_code);
                        }
                        let error_range = input.current().range;
                        loop {
                            match input.current().kind {
                                pattern_Semi!()
                                | pattern_Id!() => {
                                    // error handler 1
                                    diag.error(error_code, error_range);
                                    return Ok(())
                                }
                                pattern_EOF!()
                                | pattern_Token!()
                                | pattern_Language!()
                                | pattern_Error!()
                                | pattern_Start!()
                                | pattern_Preamble!()
                                | pattern_Pars!()
                                | pattern_Limit!() => {
                                    return Err(error_code)
                                }
                                _ => {
                                    input.advance();
                                }
                           }
                       }
                    })?;
                }
                pattern_Semi!() if !is_first => break,
                _ if is_first => {
                    return err![default_Id!()]
                }
                _ => {
                    return err![default_Id!(),
                                default_Semi!()]
                }
            }
            is_first = false;
        }
        let r#Semi = consume_Semi!(input);
        // semantic action 5
        Ok(())
    }
    fn r#rule_or_action<Input: TokenStream>(depth: u16, input: &mut Input, arena: &'a Bump, diag: &mut Diag) -> Result<&'a Element<'a>, Code> {
        check_limit!(input, depth);
        // semantic action 0
        enum ElemType {
          Action,
          Predicate,
          ErrorHandler,
        }
        let name;
        let range;
        let mut ret = Symbol::default();
        let mut pars = Symbol::default();
        let elem_type;
        let num;
        let trivia = input.trivia();
        let mut rule_regex = None;
        match input.current().kind {
            pattern_Id!() => {
                let r#Id = consume_Id!(input);
                // semantic action 1
                name = Id.0;
                range = Id.1;
            }
            pattern_Start!() => {
                let r#Start = consume_Start!(input);
                // semantic action 2
                name = Symbol::START;
                range = Start;
            }
            _ => {
                return err![default_Start!(),
                            default_Id!()]
            }
        }
        match input.current().kind {
            pattern_Colon!()
            | pattern_Code!() => {
                match input.current().kind {
                    pattern_Code!() => {
                        let r#Code = consume_Code!(input);
                        // semantic action 3
                        ret = Code.0;
                        match input.current().kind {
                            pattern_Code!() => {
                                let r#Code = consume_Code!(input);
                                // semantic action 4
                                pars = Code.0;
                            }
                            pattern_Colon!() => {}
                            _ => {
                                return err![default_Colon!(),
                                            default_Code!()]
                            }
                        }
                    }
                    pattern_Colon!() => {}
                    _ => {
                        return err![default_Colon!(),
                                    default_Code!()]
                    }
                }
                let r#Colon = consume_Colon!(input);
                match input.current().kind {
                    pattern_LPar!()
                    | pattern_LBrak!()
                    | pattern_Id!()
                    | pattern_Str!()
                    | pattern_Predicate!()
                    | pattern_Action!()
                    | pattern_ErrorHandler!() => {
                        (|| {
                            match input.current().kind {
                                pattern_LPar!()
                                | pattern_LBrak!()
                                | pattern_Id!()
                                | pattern_Str!()
                                | pattern_Predicate!()
                                | pattern_Action!()
                                | pattern_ErrorHandler!() => {
                                    let r#regex = Self::r#regex(depth + 1, input, arena, diag)?;
                                    // semantic action 5
                                    rule_regex = Some(regex);
                                    Ok(())
                                }
                                _ => {
                                    return err![default_LPar!(),
                                                default_LBrak!(),
                                                default_Id!(),
                                                default_Str!(),
                                                default_Predicate!(),
                                                default_Action!(),
                                                default_ErrorHandler!()]
                                }
                            }
                        })().or_else(|error_code| {
                            // error handling
                            if input.current().kind == TokenKind::EOF {
                                return Err(error_code);
                            }
                            let error_range = input.current().range;
                            loop {
                                match input.current().kind {
                                    pattern_Semi!() => {
                                        // error handler 1
                                        rule_regex = Some(Regex::new_invalid(arena, range));
                                        diag.error(error_code, error_range);
                                        return Ok(())
                                    }
                                    pattern_EOF!()
                                    | pattern_Token!()
                                    | pattern_Language!()
                                    | pattern_Error!()
                                    | pattern_Start!()
                                    | pattern_Preamble!()
                                    | pattern_Pars!()
                                    | pattern_Limit!()
                                    | pattern_Id!() => {
                                        return Err(error_code)
                                    }
                                    _ => {
                                        input.advance();
                                    }
                               }
                           }
                        })?;
                    }
                    pattern_Semi!() => {}
                    _ => {
                        return err![default_Semi!(),
                                    default_LPar!(),
                                    default_LBrak!(),
                                    default_Id!(),
                                    default_Str!(),
                                    default_Predicate!(),
                                    default_Action!(),
                                    default_ErrorHandler!()]
                    }
                }
                let r#Semi = consume_Semi!(input);
                // semantic action 6
                let range = Range::span(range, Semi);
                let regex = rule_regex.unwrap_or_else(|| Regex::new_empty(arena, range));
                if name == Symbol::START {
                    Ok(Element::new_start(arena, ret, pars, regex, range, trivia))
                } else {
                    Ok(Element::new_rule(arena, name, ret, pars, regex, range, trivia))
                }
            }
            pattern_Predicate!()
            | pattern_Action!()
            | pattern_ErrorHandler!() => {
                match input.current().kind {
                    pattern_Action!() => {
                        let r#Action = consume_Action!(input);
                        // semantic action 7
                        elem_type = ElemType::Action;
                        num = Action.0;
                    }
                    pattern_Predicate!() => {
                        let r#Predicate = consume_Predicate!(input);
                        // semantic action 8
                        elem_type = ElemType::Predicate;
                        num = Predicate.0;
                    }
                    pattern_ErrorHandler!() => {
                        let r#ErrorHandler = consume_ErrorHandler!(input);
                        // semantic action 9
                        elem_type = ElemType::ErrorHandler;
                        num = ErrorHandler.0;
                    }
                    _ => {
                        return err![default_Predicate!(),
                                    default_Action!(),
                                    default_ErrorHandler!()]
                    }
                }
                let r#Code = consume_Code!(input);
                // semantic action 10
                let range = Range::span(range, Code.1);
                match elem_type {
                    ElemType::Action => Ok(Element::new_action(arena, name, num, Code.0, range, trivia)),
                    ElemType::Predicate => Ok(Element::new_predicate(arena, name, num, Code.0, range, trivia)),
                    ElemType::ErrorHandler => Ok(Element::new_error_handler(arena, name, num, Code.0, range, trivia)),
                }
            }
            _ => {
                return err![default_Colon!(),
                            default_Code!(),
                            default_Predicate!(),
                            default_Action!(),
                            default_ErrorHandler!()]
            }
        }
    }
    fn r#regex<Input: TokenStream>(depth: u16, input: &mut Input, arena: &'a Bump, diag: &mut Diag) -> Result<&'a Regex<'a>, Code> {
        check_limit!(input, depth);
        let r#concat = Self::r#concat(depth + 1, input, arena, diag)?;
        // semantic action 1
        let mut regexes = BVec::new_in(arena);
        regexes.push(concat);
        loop {
            match input.current().kind {
                pattern_Or!() => {
                    let r#Or = consume_Or!(input);
                    let r#concat = Self::r#concat(depth + 1, input, arena, diag)?;
                    // semantic action 2
                    regexes.push(concat);
                }
                pattern_Semi!()
                | pattern_RPar!()
                | pattern_RBrak!() => break,
                _ => {
                    return err![default_Semi!(),
                                default_RPar!(),
                                default_RBrak!(),
                                default_Or!()]
                }
            }
        }
        // semantic action 3
        let range = Range::span(regexes.first().unwrap().range(), regexes.last().unwrap().range());
        return if regexes.len() > 1 {
            Ok(Regex::new_or(arena, regexes, range))
        } else {
            Ok(regexes[0])
        }
    }
    fn r#concat<Input: TokenStream>(depth: u16, input: &mut Input, arena: &'a Bump, diag: &mut Diag) -> Result<&'a Regex<'a>, Code> {
        check_limit!(input, depth);
        // semantic action 0
        let mut regexes = BVec::new_in(arena);
        let mut is_first = true;
        loop {
            match input.current().kind {
                pattern_LPar!()
                | pattern_LBrak!()
                | pattern_Id!()
                | pattern_Str!()
                | pattern_Predicate!()
                | pattern_Action!()
                | pattern_ErrorHandler!() => {
                    let r#postfix = Self::r#postfix(depth + 1, input, arena, diag)?;
                    // semantic action 1
                    regexes.push(postfix);
                }
                pattern_Semi!()
                | pattern_RPar!()
                | pattern_RBrak!()
                | pattern_Or!() if !is_first => break,
                _ if is_first => {
                    return err![default_LPar!(),
                                default_LBrak!(),
                                default_Id!(),
                                default_Str!(),
                                default_Predicate!(),
                                default_Action!(),
                                default_ErrorHandler!()]
                }
                _ => {
                    return err![default_LPar!(),
                                default_LBrak!(),
                                default_Id!(),
                                default_Str!(),
                                default_Predicate!(),
                                default_Action!(),
                                default_ErrorHandler!(),
                                default_Semi!(),
                                default_RPar!(),
                                default_RBrak!(),
                                default_Or!()]
                }
            }
            is_first = false;
        }
        // semantic action 2
        let range = Range::span(regexes.first().unwrap().range(), regexes.last().unwrap().range());
        if regexes.len() > 1 {
            Ok(Regex::new_concat(arena, regexes, range))
        } else {
            Ok(regexes[0])
        }
    }
    fn r#postfix<Input: TokenStream>(depth: u16, input: &mut Input, arena: &'a Bump, diag: &mut Diag) -> Result<&'a Regex<'a>, Code> {
        check_limit!(input, depth);
        // semantic action 0
        let mut regex = None;
        let mut range = input.current().range;
        (|| {
            match input.current().kind {
                pattern_LPar!()
                | pattern_LBrak!()
                | pattern_Id!()
                | pattern_Str!()
                | pattern_Predicate!()
                | pattern_Action!()
                | pattern_ErrorHandler!() => {
                    let r#atomic = Self::r#atomic(depth + 1, input, arena, diag)?;
                    // semantic action 1
                    regex = Some(atomic);
                    range = atomic.range();
                    loop {
                        match input.current().kind {
                            pattern_Star!()
                            | pattern_Plus!() => {
                                match input.current().kind {
                                    pattern_Star!() => {
                                        let r#Star = consume_Star!(input);
                                        // semantic action 2
                                        range = Range::span(range, Star);
                                        regex = Some(Regex::new_star(arena, regex.unwrap(), range));
                                    }
                                    pattern_Plus!() => {
                                        let r#Plus = consume_Plus!(input);
                                        // semantic action 3
                                        range = Range::span(range, Plus);
                                        regex = Some(Regex::new_plus(arena, regex.unwrap(), range));
                                    }
                                    _ => {
                                        return err![default_Star!(),
                                                    default_Plus!()]
                                    }
                                }
                            }
                            pattern_Semi!()
                            | pattern_LPar!()
                            | pattern_RPar!()
                            | pattern_LBrak!()
                            | pattern_RBrak!()
                            | pattern_Or!()
                            | pattern_Id!()
                            | pattern_Str!()
                            | pattern_Predicate!()
                            | pattern_Action!()
                            | pattern_ErrorHandler!() => break,
                            _ => {
                                return err![default_Semi!(),
                                            default_LPar!(),
                                            default_RPar!(),
                                            default_LBrak!(),
                                            default_RBrak!(),
                                            default_Or!(),
                                            default_Star!(),
                                            default_Plus!(),
                                            default_Id!(),
                                            default_Str!(),
                                            default_Predicate!(),
                                            default_Action!(),
                                            default_ErrorHandler!()]
                            }
                        }
                    }
                    Ok(())
                }
                _ => {
                    return err![default_LPar!(),
                                default_LBrak!(),
                                default_Id!(),
                                default_Str!(),
                                default_Predicate!(),
                                default_Action!(),
                                default_ErrorHandler!()]
                }
            }
        })().or_else(|error_code| {
            // error handling
            if input.current().kind == TokenKind::EOF {
                return Err(error_code);
            }
            let error_range = input.current().range;
            loop {
                match input.current().kind {
                    pattern_Semi!()
                    | pattern_LPar!()
                    | pattern_RPar!()
                    | pattern_LBrak!()
                    | pattern_RBrak!()
                    | pattern_Or!()
                    | pattern_Id!()
                    | pattern_Str!()
                    | pattern_Predicate!()
                    | pattern_Action!()
                    | pattern_ErrorHandler!() => {
                        // error handler 1
                        diag.error(error_code, error_range);
                        return Ok(())
                    }
                    pattern_EOF!()
                    | pattern_Token!()
                    | pattern_Language!()
                    | pattern_Error!()
                    | pattern_Start!()
                    | pattern_Preamble!()
                    | pattern_Pars!()
                    | pattern_Limit!() => {
                        return Err(error_code)
                    }
                    _ => {
                        input.advance();
                    }
               }
           }
        })?;
        // semantic action 4
        Ok(regex.unwrap_or_else(|| Regex::new_invalid(arena, range)))
    }
    fn r#atomic<Input: TokenStream>(depth: u16, input: &mut Input, arena: &'a Bump, diag: &mut Diag) -> Result<&'a Regex<'a>, Code> {
        check_limit!(input, depth);
        match input.current().kind {
            pattern_Id!() => {
                let r#Id = consume_Id!(input);
                // semantic action 1
                Ok(Regex::new_id(arena, Id.0, Id.1))
            }
            pattern_Str!() => {
                let r#Str = consume_Str!(input);
                // semantic action 2
                Ok(Regex::new_str(arena, Str.0, Str.1))
            }
            pattern_Predicate!() => {
                let r#Predicate = consume_Predicate!(input);
                // semantic action 3
                Ok(Regex::new_predicate(arena, Predicate.0, Predicate.1))
            }
            pattern_Action!() => {
                let r#Action = consume_Action!(input);
                // semantic action 4
                Ok(Regex::new_action(arena, Action.0, Action.1))
            }
            pattern_ErrorHandler!() => {
                let r#ErrorHandler = consume_ErrorHandler!(input);
                // semantic action 5
                Ok(Regex::new_error_handler(arena, ErrorHandler.0, ErrorHandler.1))
            }
            pattern_LPar!() => {
                let r#LPar = consume_LPar!(input);
                let r#regex = Self::r#regex(depth + 1, input, arena, diag)?;
                let r#RPar = consume_RPar!(input);
                // semantic action 6
                let range = Range::span(LPar, RPar);
                Ok(Regex::new_paren(arena, regex, range))
            }
            pattern_LBrak!() => {
                let r#LBrak = consume_LBrak!(input);
                let r#regex = Self::r#regex(depth + 1, input, arena, diag)?;
                let r#RBrak = consume_RBrak!(input);
                // semantic action 7
                let range = Range::span(LBrak, RBrak);
                Ok(Regex::new_option(arena, regex, range))
            }
            _ => {
                return err![default_LPar!(),
                            default_LBrak!(),
                            default_Id!(),
                            default_Str!(),
                            default_Predicate!(),
                            default_Action!(),
                            default_ErrorHandler!()]
            }
        }
    }
}
