// generated by lelwel

mod imp;

pub use imp::*;

use super::parser::*;
use super::token::*;
use bumpalo::Bump;
use std::cell::Cell;

/// Abstract syntax tree

#[derive(Debug)]
pub struct Ast<'a, R> {
    arena: Box<Bump>,
    root: Cell<Option<&'a R>>,
}

impl<'a, R> Ast<'a, R> {
    pub fn new() -> Self {
        Self {
            arena: Box::new(Bump::new()),
            root: Cell::new(None),
        }
    }
    pub fn set_root(&'a self, root: R) {
        self.root.set(Some(self.arena.alloc(root)))
    }
    pub fn root(&self) -> Option<&'a R> {
        self.root.get()
    }
    pub fn arena(&self) -> &Bump {
        &self.arena
    }
}

/// Reference to another node in the `Ast`.
pub struct Ref<'a, T> {
    target: Cell<Option<&'a T>>,
}

#[allow(dead_code)]
impl<'a, T> Ref<'a, T> {
    /// Creates a new `Ref`.
    pub fn new(init: Option<&'a T>) -> Ref<'a, T> {
        Ref {
            target: Cell::new(init),
        }
    }

    /// Sets the target of the `Ref`.
    pub fn set(&self, value: &'a T) {
        self.target.set(Some(value));
    }

    /// Gets the target of the `Ref`.
    pub fn get(&self) -> Option<&'a T> {
        self.target.get()
    }
}

impl<'a, T> std::fmt::Debug for Ref<'a, T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ptr = match self.get() {
            Some(e) => e,
            None => std::ptr::null(),
        };
        std::fmt::Pointer::fmt(&ptr, f)
    }
}

impl<'a, T> std::fmt::Pointer for Ref<'a, T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ptr = match self.get() {
            Some(e) => e,
            None => std::ptr::null(),
        };
        std::fmt::Pointer::fmt(&ptr, f)
    }
}
