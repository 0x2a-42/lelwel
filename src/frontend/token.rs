#![allow(dead_code)]

use super::parser::TokenKind;
use std::cmp::Ordering;
use std::fmt;

/// A token that is generated by the lexer.
#[derive(Clone, Debug)]
pub struct Token {
    /// Kind of the token (e.g. identifier, punctuator, ...).
    pub kind: TokenKind,
    /// Range of the token.
    pub range: Range,
}

impl Token {
    /// Creates a new token with the given kind, range, and channel.
    ///
    /// # Examples:
    /// Basic usage:
    /// ```
    /// # use lelwel::frontend::{token::*, parser::*};
    /// let range = Range::new(Position::new(1, 45), Position::new(1, 46));
    /// let tok = Token::new(TokenKind::Semi, range);
    /// ```
    pub fn new(kind: TokenKind, range: Range) -> Token {
        Token { kind, range }
    }
}

impl Default for Token {
    fn default() -> Token {
        Token::new(TokenKind::EOF, Range::default())
    }
}

/// A position in a text document, where lines and characters are zero based.
///
/// # Examples
/// Basic usage:
/// ```
/// # use lelwel::frontend::token::Position;
/// let start_of_this_identifier = Position::new(0, 4);
/// ```
#[derive(Eq, PartialEq, Clone, Copy, Debug)]
pub struct Position {
    /// Line number of the position.
    pub line: u32,
    /// Unicode code point offset in the line.
    pub character: u32,
}

impl Position {
    /// Creates a new Position with the given line and character offset.
    ///
    /// # Examples
    /// Basic usage:
    /// ```
    /// # use lelwel::frontend::token::Position;
    /// let pos = Position::new(1, 2);
    /// ```
    pub fn new(line: u32, character: u32) -> Position {
        Position { line, character }
    }
}

impl Default for Position {
    fn default() -> Position {
        Position::new(0, 0)
    }
}

impl fmt::Display for Position {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.line + 1, self.character + 1)
    }
}

impl Ord for Position {
    fn cmp(&self, other: &Self) -> Ordering {
        if self.line < other.line || (self.line == other.line && self.character < other.character) {
            Ordering::Less
        } else if self.line == other.line && self.character == other.character {
            Ordering::Equal
        } else {
            Ordering::Greater
        }
    }
}

impl PartialOrd for Position {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

#[cfg(feature = "lsp-types")]
impl From<lsp_types::Position> for Position {
    fn from(pos: lsp_types::Position) -> Self {
        Position::new(pos.line, pos.character)
    }
}

#[cfg(feature = "lsp-types")]
impl From<Position> for lsp_types::Position {
    fn from(pos: Position) -> Self {
        lsp_types::Position::new(pos.line, pos.character)
    }
}

/// A range between two positions in a text document, where the end position is exclusive.
///
/// # Examples
/// Basic usage:
/// ```
/// # use lelwel::frontend::token::*;
/// let range_of_this_identifier = Range::new(Position::new(1, 4), Position::new(1, 28));
/// ```
#[derive(Eq, PartialEq, Clone, Copy, Debug)]
pub struct Range {
    /// The range's start position.
    pub start: Position,
    /// The range's end position.
    pub end: Position,
}

impl Range {
    /// Creates a new Range between the given positions.
    ///
    /// # Examples
    /// Basic usage:
    /// ```
    /// # use lelwel::frontend::token::*;
    /// let range = Range::new(Position::new(0, 1), Position::new(0, 2));
    /// ```
    pub fn new(start: Position, end: Position) -> Range {
        Range { start, end }
    }

    /// Creates a new Range that spans between the start of the first range and the end of the
    /// second range.
    ///
    /// # Examples
    /// Basic usage:
    /// ```
    /// # use lelwel::frontend::token::*;
    /// let first = Range::new(Position::new(0, 1), Position::new(0, 2));
    /// let second = Range::new(Position::new(0, 4), Position::new(0, 5));
    /// let range = Range::span(first, second);
    ///
    /// assert_eq!(range, Range::new(Position::new(0, 1), Position::new(0, 5)));
    /// ```
    pub fn span(first: Range, last: Range) -> Range {
        Range {
            start: first.start,
            end: last.end,
        }
    }

    /// Checks if the given position is contained within the range.
    ///
    /// # Examples
    /// Basic usage:
    /// ```
    /// # use lelwel::frontend::token::*;
    /// let pos = Position::new(3, 5);
    /// let range = Range::new(Position::new(2, 4), Position::new(7, 0));
    ///
    /// assert!(range.contains(pos));
    /// ```
    pub fn contains(&self, pos: Position) -> bool {
        self.start <= pos && pos <= self.end
    }
}

impl Default for Range {
    fn default() -> Range {
        Range::new(Position::default(), Position::default())
    }
}

impl fmt::Display for Range {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}-{}", self.start, self.end)
    }
}

#[cfg(feature = "lsp-types")]
impl From<lsp_types::Range> for Range {
    fn from(range: lsp_types::Range) -> Self {
        Range::new(Position::from(range.start), Position::from(range.end))
    }
}

#[cfg(feature = "lsp-types")]
impl From<Range> for lsp_types::Range {
    fn from(range: Range) -> Self {
        lsp_types::Range::new(
            lsp_types::Position::from(range.start),
            lsp_types::Position::from(range.end),
        )
    }
}

/// Trait for objects with a range.
pub trait Ranged {
    fn range(&self) -> Range;
}

/// Trait for searching for `Ranged` objects.
pub trait Lookup {
    type Node;
    fn lookup(&self, pos: Position) -> Option<&Self::Node>;
}

impl<T: Ranged> Lookup for T {
    type Node = T;
    fn lookup(&self, pos: Position) -> Option<&Self::Node> {
        if self.range().contains(pos) {
            Some(self)
        } else {
            None
        }
    }
}

impl<T: Ranged> Lookup for [&T] {
    type Node = T;
    fn lookup(&self, pos: Position) -> Option<&Self::Node> {
        let contained = |node: &&T| {
            if node.range().start > pos {
                std::cmp::Ordering::Greater
            } else if node.range().end < pos {
                std::cmp::Ordering::Less
            } else {
                std::cmp::Ordering::Equal
            }
        };
        if let Ok(index) = self.binary_search_by(contained) {
            Some(self[index])
        } else {
            None
        }
    }
}

/// A stream of tokens.
pub trait TokenStream {
    /// Gets the current element in the stream.
    fn current(&self) -> Token;
    /// Peeks an element in the stream.
    fn peek(&mut self, la: usize) -> Token;
    /// Advances to the next element in the stream.
    fn advance(&mut self);
    /// Gets the trivia tokens.
    fn trivia(&mut self) -> Option<Token>;
    /// Ingnores the rest of the stream.
    fn finalize(&mut self);
}

pub struct TokenBuffer {
    tokens: Vec<(Token, Option<Token>)>,
    pos: usize,
}

impl TokenBuffer {
    pub fn new() -> TokenBuffer {
        TokenBuffer {
            tokens: vec![],
            pos: 0,
        }
    }
    pub fn push(&mut self, token: Token) {
        self.tokens.push((token, None));
    }
    pub fn set_trivia(&mut self, token: Token) {
        self.tokens.last_mut().unwrap().1 = Some(token);
    }
}

impl TokenStream for TokenBuffer {
    fn current(&self) -> Token {
        if self.pos < self.tokens.len() {
            self.tokens[self.pos].0.clone()
        } else {
            self.tokens.last().unwrap().0.clone()
        }
    }
    fn peek(&mut self, la: usize) -> Token {
        if self.pos + la < self.tokens.len() {
            self.tokens[self.pos + la].0.clone()
        } else {
            self.tokens.last().unwrap().0.clone()
        }
    }
    fn advance(&mut self) {
        if self.pos < self.tokens.len() {
            self.pos += 1
        }
    }
    fn trivia(&mut self) -> Option<Token> {
        self.tokens[self.pos].1.clone()
    }
    fn finalize(&mut self) {
        self.pos = self.tokens.len()
    }
}
