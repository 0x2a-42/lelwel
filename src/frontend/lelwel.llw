language rust;

/// Keyword
token Token='token' Language='language' Import='import' Error='error'
      Start='start' Preamble='preamble' Pars='parameters' Limit='limit';
/// Punctuator
token Colon=':' Semi=';' Equal='=' LPar='(' RPar=')' Or='|' Star='*' Plus='+'
      Quest='?';
/// Identifier for rules and tokens
token Id{Symbol}='<identifier>' Str{Symbol}='<string literal>';
/// Segment of code delimited by `{` and `}`
token Code{Symbol}='<code segment>';
/// Integer token only used for setting the recursion depth limit
token Int{u16}='<integer>';
/// Semantic predicate identifier
token Predicate{u64}='<semantic predicate>';
/// Semantic action identifier
token Action{u64}='<semantic action>';
/// Documentation comment
token _Comment{Symbol};

/// Module consisting of tokens, grammar rules, actions and other definitions
start{Module<'a>}:
  (
    #1 tokens
  | rule_or_action #2
  | 'preamble' Code #3
  | 'parameters' Code #4
  | 'language' Id ';' #5
  | 'import' Str ';' #6
  | 'error' Code #7
  | 'limit' Int ';' #8
  | error #9
  )* #10
;
/// Token list definition
tokens{()}{elements: &mut BVec<'a, &'a Element<'a>>}:
  'token' (
    (Id #1 (Code #2)? ('=' Str #3)? #4)+
  | error #5
  ) ';' #6
;
/// Grammar rule, action, or predicate definition
rule_or_action{&'a Element<'a>}:
  (Id #1 | 'start' #2) (
    (Code #3 (Code #4)?)? ':' regex ';' #5
  | (Action #6 | Predicate #7) Code #8
  )
;
/// Alternation (e.g. `R1 | R2 | ...`)
regex{&'a Regex<'a>}:
  concat #1 ('|' concat #2)* #3
;
/// Concatenation (e.g. `R1 R2 ...`)
concat{&'a Regex<'a>}:
  (postfix #1)+ #2
;
/// Postfix operators (e.g. Kleene star `R*`)
postfix{&'a Regex<'a>}:
  (atomic #1 ('*' #2 | '+' #3 | '?' #4)* | error #5) #6
;
/// Atomic or parenthesized regular expressions
atomic{&'a Regex<'a>}:
  Id #1
| Str #2
| Predicate #3
| Action #4
| 'error' #5
| '(' regex ')' #6
;


limit 128;

preamble {
    use super::symbol::Symbol;
    use super::ast::*;
    use super::diag::*;
    use bumpalo::{Bump, collections::Vec as BVec};
}
parameters { arena: &'a Bump, diag: &mut Diag }
error { Code }

// semantic actions

/// Create a vector for elements
start#0 { let mut elements = BVec::new_in(arena); }
/// Bind the name `elements` for the parameter of `tokens`
start#1 { let elements = &mut elements; }
/// Push to `elements`
start#2 { elements.push(rule_or_action); }
/// Push to `elements`
start#3 { elements.push(Element::new_preamble(arena, Code.0, Code.1)); }
/// Push to `elements`
start#4 { elements.push(Element::new_parameters(arena, Code.0, Code.1)); }
/// Push to `elements`
start#5 { elements.push(Element::new_language(arena, Id.0, Id.1)); }
/// Push to `elements`
start#6 { elements.push(Element::new_import(arena, Str.0, Str.1)); }
/// Push to `elements`
start#7 { elements.push(Element::new_error(arena, Code.0, Code.1)); }
/// Push to `elements`
start#8 { elements.push(Element::new_limit(arena, Int.0, Int.1)); }
/// Create diagnostic for error and invalid element
start#9 {
    diag.error(error_code, error_range);
    elements.push(Element::new_invalid(arena, error_range));
}
/// Create the module
start#10 { Ok(Module::new(elements)) }

/// Save the last trivia token for the documentation comment
tokens#0 { let trivia = input.trivia(); }
/// Define variables for parts of token definition
tokens#1 {
    let mut range = Id.1;
    let mut ty = Symbol::default();
    let mut sym = Symbol::default();
}
/// Set variable for token type and update range
tokens#2 {
    ty = Code.0;
    range = Range::span(range, Code.1);
}
/// Set variable for token symbol and update range
tokens#3 {
    sym = Str.0;
    range = Range::span(range, Str.1);
}
/// Create and push token definition
tokens#4 { elements.push(Element::new_token(arena, Id.0, ty, sym, range, trivia.clone())); }
/// Create diagnostic for error
tokens#5 { diag.error(error_code, error_range); }
/// Return successful
tokens#6 { Ok(()) }

/// Define variables
rule_or_action#0 {
    let name;
    let range;
    let mut ret = Symbol::default();
    let mut pars = Symbol::default();
    let is_act;
    let num;
    let trivia = input.trivia();
}
/// Set name and range
rule_or_action#1 {
    name = Id.0;
    range = Id.1;
}
/// Set name and range
rule_or_action#2 {
    name = Symbol::START;
    range = Start;
}
/// Set return type
rule_or_action#3 { ret = Code.0; }
/// Set parameters
rule_or_action#4 { pars = Code.0; }
/// Create the rule
rule_or_action#5 {
    let range = Range::span(range, Semi);
    if name == Symbol::START {
        Ok(Element::new_start(arena, ret, pars, regex, range, trivia))
    } else {
        Ok(Element::new_rule(arena, name, ret, pars, regex, range, trivia))
    }
}
/// Set action number
rule_or_action#6 {
    is_act = true;
    num = Action.0;
}
/// Set predicate number
rule_or_action#7 {
    is_act = false;
    num = Predicate.0;
}
/// Create action or predicate
rule_or_action#8 {
    let range = Range::span(range, Code.1);
    if is_act {
        Ok(Element::new_action(arena, name, num, Code.0, range, trivia))
    } else {
        Ok(Element::new_predicate(arena, name, num, Code.0, range, trivia))
    }
}

/// Create vector for operands
regex#1 {
    let mut regexes = BVec::new_in(arena);
    regexes.push(concat);
}
/// Push operand
regex#2 { regexes.push(concat); }
/// Create alternative if there were more than one operands
regex#3 {
    let range = Range::span(regexes.first().unwrap().range(), regexes.last().unwrap().range());
    return if regexes.len() > 1 {
        Ok(Regex::new_or(arena, regexes, range))
    } else {
        Ok(regexes[0])
    }
}

/// Create vector for operands
concat#0 { let mut regexes = BVec::new_in(arena); }
/// Push operand
concat#1 { regexes.push(postfix); }
/// Create concatenation if there were more than one operands
concat#2 {
    let range = Range::span(regexes.first().unwrap().range(), regexes.last().unwrap().range());
    if regexes.len() > 1 {
        Ok(Regex::new_concat(arena, regexes, range))
    } else {
        Ok(regexes[0])
    }
}

/// Initialize regex and range variables
postfix#0 {
    let mut regex = None;
    let mut range = input.current().range;
}
/// Set regex to atomic and update range
postfix#1 {
    regex = Some(atomic);
    range = atomic.range();
}
/// Create star regex
postfix#2 {
    range = Range::span(range, Star);
    regex = Some(Regex::new_star(arena, regex.unwrap(), range));
}
/// Create plus regex
postfix#3 {
    range = Range::span(range, Plus);
    regex = Some(Regex::new_plus(arena, regex.unwrap(), range));
}
/// Create option regex
postfix#4 {
    range = Range::span(range, Quest);
    regex = Some(Regex::new_option(arena, regex.unwrap(), range));
}
/// Create diagnostic for error, result will be the last successfuly parsed regex
postfix#5 { diag.error(error_code, error_range); }
/// Return result regex or invalid regex if parsing was not successful
postfix#6 { Ok(regex.unwrap_or_else(|| Regex::new_invalid(arena, range))) }

/// Create identifier
atomic#1 { Ok(Regex::new_id(arena, Id.0, Id.1)) }
/// Create string
atomic#2 { Ok(Regex::new_str(arena, Str.0, Str.1)) }
/// Create semantic predicate
atomic#3 { Ok(Regex::new_predicate(arena, Predicate.0, Predicate.1)) }
/// Create semantic action
atomic#4 { Ok(Regex::new_action(arena, Action.0, Action.1)) }
/// Create error handler
atomic#5 { Ok(Regex::new_error(arena, Error)) }
/// Create parenthesized regular expression
atomic#6 {
    let range = Range::span(LPar, RPar);
    Ok(Regex::new_paren(arena, regex, range))
}
