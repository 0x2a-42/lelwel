language rust;

/// Keyword
token Token='token' Language='language' Error='error' Start='start'
      Preamble='preamble' Pars='parameters' Limit='limit';
/// Punctuator
token Colon=':' Semi=';' Equal='=' LPar='(' RPar=')' LBrak='[' RBrak=']'
      Or='|' Star='*' Plus='+';
/// Identifier for rules and tokens
token Id{Symbol}='<identifier>' Str{Symbol}='<string literal>';
/// Segment of code delimited by `{` and `}`
token Code{Symbol}='<code segment>';
/// Integer token only used for setting the recursion depth limit
token Int{u16}='<integer>';
/// Semantic predicate identifier
token Predicate{u64}='<semantic predicate>';
/// Semantic action identifier
token Action{u64}='<semantic action>';
/// Error handler identifier
token ErrorHandler{u64}='<error handler>';
/// Documentation comment
token _Comment{Symbol};

/// Module consisting of tokens, grammar rules, actions and other definitions
start{Module<'a>}:
  (
    #1 tokens
  | rule_or_action #2
  | 'preamble' Code #3
  | 'parameters' Code #4
  | 'language' Id ';' #5
  | 'error' Code #6
  | 'limit' Int ';' #7
  | !1
  )* #8
;
/// Token list definition
tokens{()}{elements: &mut BVec<'a, &'a Element<'a>>}:
  'token' ((Id #1 [Code #2] ['=' Str #3] #4)+ | !1) ';' #5
;
/// Grammar rule, action, or predicate definition
rule_or_action{&'a Element<'a>}:
  (Id #1 | 'start' #2) (
    [Code #3 [Code #4]] ':' [regex #5 | !1] ';' #6
  | (Action #7 | Predicate #8 | ErrorHandler #9) Code #10
  )
;
/// Alternation (e.g. `R1 | R2 | ...`)
regex{&'a Regex<'a>}:
  concat #1 ('|' concat #2)* #3
;
/// Concatenation (e.g. `R1 R2 ...`)
concat{&'a Regex<'a>}:
  (postfix #1)+ #2
;
/// Postfix operators (e.g. Kleene star `R*`)
postfix{&'a Regex<'a>}:
  (atomic #1 ('*' #2 | '+' #3)* | !1) #4
;
/// Atomic or parenthesized regular expressions
atomic{&'a Regex<'a>}:
  Id #1
| Str #2
| Predicate #3
| Action #4
| ErrorHandler #5
| '(' regex ')' #6
| '[' regex ']' #7
;


limit 128;

preamble {
    use super::symbol::Symbol;
    use super::ast::*;
    use super::diag::*;
    use bumpalo::{Bump, collections::Vec as BVec};
}
parameters { arena: &'a Bump, diag: &mut Diag }
error { Code }

// semantic actions

/// Create a vector for elements
start#0 { let mut elements = BVec::new_in(arena); }
/// Bind the name `elements` for the parameter of `tokens`
start#1 { let elements = &mut elements; }
/// Push to `elements`
start#2 { elements.push(rule_or_action); }
/// Push to `elements`
start#3 { elements.push(Element::new_preamble(arena, Code.0, Code.1)); }
/// Push to `elements`
start#4 { elements.push(Element::new_parameters(arena, Code.0, Code.1)); }
/// Push to `elements`
start#5 { elements.push(Element::new_language(arena, Id.0, Id.1)); }
/// Push to `elements`
start#6 { elements.push(Element::new_error_code(arena, Code.0, Code.1)); }
/// Push to `elements`
start#7 { elements.push(Element::new_limit(arena, Int.0, Int.1)); }
/// Create the module
start#8 { Ok(Module::new(elements)) }
/// Create diagnostic for error and invalid element
start!1 {
    diag.error(error_code, error_range);
    elements.push(Element::new_invalid(arena, error_range));
}

/// Save the last trivia token for the documentation comment
tokens#0 { let trivia = input.trivia(); }
/// Define variables for parts of token definition
tokens#1 {
    let mut range = Id.1;
    let mut ty = Symbol::default();
    let mut sym = Symbol::default();
}
/// Set variable for token type and update range
tokens#2 {
    ty = Code.0;
    range = Range::span(range, Code.1);
}
/// Set variable for token symbol and update range
tokens#3 {
    sym = Str.0;
    range = Range::span(range, Str.1);
}
/// Create and push token definition
tokens#4 { elements.push(Element::new_token(arena, Id.0, ty, sym, range, trivia.clone())); }
/// Return successful
tokens#5 { Ok(()) }
/// Create diagnostic for error
tokens!1 { diag.error(error_code, error_range); }

/// Define variables
rule_or_action#0 {
    enum ElemType {
      Action,
      Predicate,
      ErrorHandler,
    }
    let name;
    let range;
    let mut ret = Symbol::default();
    let mut pars = Symbol::default();
    let elem_type;
    let num;
    let trivia = input.trivia();
    let mut rule_regex = None;
}
/// Set name and range
rule_or_action#1 {
    name = Id.0;
    range = Id.1;
}
/// Set name and range
rule_or_action#2 {
    name = Symbol::START;
    range = Start;
}
/// Set return type
rule_or_action#3 { ret = Code.0; }
/// Set parameters
rule_or_action#4 { pars = Code.0; }
/// Set regex
rule_or_action#5 { rule_regex = Some(regex); }
/// Create the rule
rule_or_action#6 {
    let range = Range::span(range, Semi);
    let regex = rule_regex.unwrap_or_else(|| Regex::new_empty(arena, range));
    if name == Symbol::START {
        Ok(Element::new_start(arena, ret, pars, regex, range, trivia))
    } else {
        Ok(Element::new_rule(arena, name, ret, pars, regex, range, trivia))
    }
}
/// Set action number
rule_or_action#7 {
    elem_type = ElemType::Action;
    num = Action.0;
}
/// Set predicate number
rule_or_action#8 {
    elem_type = ElemType::Predicate;
    num = Predicate.0;
}
/// Set predicate number
rule_or_action#9 {
    elem_type = ElemType::ErrorHandler;
    num = ErrorHandler.0;
}
/// Create action or predicate
rule_or_action#10 {
    let range = Range::span(range, Code.1);
    match elem_type {
        ElemType::Action => Ok(Element::new_action(arena, name, num, Code.0, range, trivia)),
        ElemType::Predicate => Ok(Element::new_predicate(arena, name, num, Code.0, range, trivia)),
        ElemType::ErrorHandler => Ok(Element::new_error_handler(arena, name, num, Code.0, range, trivia)),
    }
}
rule_or_action!1 {
  rule_regex = Some(Regex::new_invalid(arena, range));
  diag.error(error_code, error_range);
}

/// Create vector for operands
regex#1 {
    let mut regexes = BVec::new_in(arena);
    regexes.push(concat);
}
/// Push operand
regex#2 { regexes.push(concat); }
/// Create alternative if there were more than one operands
regex#3 {
    let range = Range::span(regexes.first().unwrap().range(), regexes.last().unwrap().range());
    return if regexes.len() > 1 {
        Ok(Regex::new_or(arena, regexes, range))
    } else {
        Ok(regexes[0])
    }
}

/// Create vector for operands
concat#0 { let mut regexes = BVec::new_in(arena); }
/// Push operand
concat#1 { regexes.push(postfix); }
/// Create concatenation if there were more than one operands
concat#2 {
    let range = Range::span(regexes.first().unwrap().range(), regexes.last().unwrap().range());
    if regexes.len() > 1 {
        Ok(Regex::new_concat(arena, regexes, range))
    } else {
        Ok(regexes[0])
    }
}

/// Initialize regex and range variables
postfix#0 {
    let mut regex = None;
    let mut range = input.current().range;
}
/// Set regex to atomic and update range
postfix#1 {
    regex = Some(atomic);
    range = atomic.range();
}
/// Create star regex
postfix#2 {
    range = Range::span(range, Star);
    regex = Some(Regex::new_star(arena, regex.unwrap(), range));
}
/// Create plus regex
postfix#3 {
    range = Range::span(range, Plus);
    regex = Some(Regex::new_plus(arena, regex.unwrap(), range));
}
/// Return result regex or invalid regex if parsing was not successful
postfix#4 { Ok(regex.unwrap_or_else(|| Regex::new_invalid(arena, range))) }
/// Create diagnostic for error, result will be the last successfully parsed regex
postfix!1 { diag.error(error_code, error_range); }

/// Create identifier
atomic#1 { Ok(Regex::new_id(arena, Id.0, Id.1)) }
/// Create string
atomic#2 { Ok(Regex::new_str(arena, Str.0, Str.1)) }
/// Create semantic predicate
atomic#3 { Ok(Regex::new_predicate(arena, Predicate.0, Predicate.1)) }
/// Create semantic action
atomic#4 { Ok(Regex::new_action(arena, Action.0, Action.1)) }
/// Create error handler
atomic#5 { Ok(Regex::new_error_handler(arena, ErrorHandler.0, ErrorHandler.1)) }
/// Create parenthesized regex
atomic#6 {
    let range = Range::span(LPar, RPar);
    Ok(Regex::new_paren(arena, regex, range))
}
/// Create option regex
atomic#7 {
    let range = Range::span(LBrak, RBrak);
    Ok(Regex::new_option(arena, regex, range))
}
