// generated by lelwel 0.5.0

macro_rules! consume {
    ($tok:ident, $sym:literal, $current:expr, $input:expr, $diags:expr) => {{
        let span = $input.span();
        if let Token::$tok = $current {
            Self::advance($current, $input, $diags);
            span
        } else {
            return err![$input, $sym];
        }
    }};
    ($tok:ident, $sym:literal, $current:expr, $input:expr, $diags:expr, _) => {{
        let span = $input.span();
        if let Token::$tok(..) = $current {
            if let Token::$tok(val) = Self::advance($current, $input, $diags) {
                (val, span)
            } else {
                unreachable!()
            }
        } else {
            return err![$input, $sym];
        }
    }};
}

pub struct Parser;

#[allow(
    clippy::needless_return,
    clippy::let_unit_value,
    non_snake_case,
    unused
)]
impl<'a> Parser {
    fn advance(
        current: &mut Token<'a>,
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
    ) -> Token<'a> {
        loop {
            match input.next_token() {
                Ok(tok) => {
                    return std::mem::replace(current, tok);
                }
                Err(err) => {
                    diags.push(err.into_diagnostic(input.span()));
                }
            }
        }
    }
    pub fn parse(
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
        interner: &mut StringInterner<'a>,
    ) -> Option<Module<'a>> {
        let mut current = Token::EOF;
        let current = &mut current;
        Self::advance(current, input, diags);
        let out = match Self::start(current, input, diags, interner) {
            Ok(out) => Some(out),
            Err(diag) => {
                diags.push(diag);
                None
            }
        };
        if *current != Token::EOF {
            let err: Result<(), Diagnostic> = err![input, "<end of file>"];
            diags.push(err.unwrap_err());
        }
        out
    }
    fn start(
        current: &mut Token<'a>,
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
        interner: &mut StringInterner<'a>,
    ) -> Result<Module<'a>, Diagnostic> {
        let lelwel_depth = 0;
        // semantic action 0
        let mut module = Module::new(input.uri);
        loop {
            match current {
                Token::Id(..) | Token::Pars | Token::Start | Token::Token => {
                    (|| {
                        match current {
                            Token::Token => {
                                // semantic action 1
                                let module = &mut module;
                                let r#tokens = Self::r#tokens(
                                    lelwel_depth + 1,
                                    current,
                                    input,
                                    diags,
                                    interner,
                                    module,
                                )?;
                                Ok(())
                            }
                            Token::Id(..) | Token::Start => {
                                // semantic action 2
                                let module = &mut module;
                                let r#rule_or_action = Self::r#rule_or_action(
                                    lelwel_depth + 1,
                                    current,
                                    input,
                                    diags,
                                    interner,
                                    module,
                                )?;
                                Ok(())
                            }
                            Token::Pars => {
                                let r#Pars = consume!(Pars, "parameters", current, input, diags);
                                let r#Code =
                                    consume!(Code, "<code segment>", current, input, diags, _);
                                // semantic action 3
                                module.parameters =
                                    Element::new_parameters(&mut module, Code.0, &Code.1);
                                Ok(())
                            }
                            _ => {
                                return err![input, "<identifier>", "parameters", "start", "token"]
                            }
                        }
                    })()
                    .or_else(|diagnostic| {
                        // error handling
                        loop {
                            match current {
                                Token::EOF
                                | Token::Id(..)
                                | Token::Pars
                                | Token::Start
                                | Token::Token => {
                                    // error handler 1
                                    diags.push(diagnostic);
                                    Element::new_invalid(&mut module, &input.span());
                                    return Ok::<(), Diagnostic>(());
                                }
                                _ => {
                                    Self::advance(current, input, diags);
                                }
                            }
                        }
                    })?;
                }
                Token::EOF => break,
                _ => {
                    return err![
                        input,
                        "<end of file>",
                        "<identifier>",
                        "parameters",
                        "start",
                        "token"
                    ]
                }
            }
        }
        // semantic action 4
        Ok(module)
    }
    fn r#tokens(
        lelwel_depth: u64,
        current: &mut Token<'a>,
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
        interner: &mut StringInterner<'a>,
        module: &mut Module<'a>,
    ) -> Result<(), Diagnostic> {
        check_limit!(input, current, lelwel_depth);
        // semantic action 0
        let doc = std::mem::take(&mut input.last_doc_comment);
        let r#Token = consume!(Token, "token", current, input, diags);
        let mut lelwel_is_first = true;
        loop {
            match current {
                Token::Id(..) => {
                    (|| {
                        let r#Id = consume!(Id, "<identifier>", current, input, diags, _);
                        // semantic action 1
                        let mut span = Id.1;
                        let mut ty = "";
                        let mut sym = Symbol::default();
                        match current {
                            Token::Code(..) => {
                                let r#Code =
                                    consume!(Code, "<code segment>", current, input, diags, _);
                                // semantic action 2
                                ty = Code.0;
                                span = span.start..Code.1.end;
                            }
                            Token::Equal | Token::Id(..) | Token::Semi => {}
                            _ => return err![input, "<code segment>", "=", "<identifier>", ";"],
                        }
                        match current {
                            Token::Equal => {
                                let r#Equal = consume!(Equal, "=", current, input, diags);
                                let r#Str =
                                    consume!(Str, "<string literal>", current, input, diags, _);
                                // semantic action 3
                                sym = interner.get(Str.0);
                                span = span.start..Str.1.end;
                            }
                            Token::Id(..) | Token::Semi => {}
                            _ => return err![input, "=", "<identifier>", ";"],
                        }
                        // semantic action 4
                        Element::new_token(module, interner.get(Id.0), ty, sym, &span, doc);
                        match current {
                            Token::Id(..) | Token::Semi => Ok(()),
                            _ => return err![input, "<identifier>", ";"],
                        }
                    })()
                    .or_else(|diagnostic| {
                        // error handling
                        loop {
                            match current {
                                Token::Id(..) | Token::Semi => {
                                    // error handler 1
                                    diags.push(diagnostic);
                                    return Ok::<(), Diagnostic>(());
                                }
                                Token::EOF | Token::Pars | Token::Start | Token::Token => {
                                    return Err(diagnostic)
                                }
                                _ => {
                                    Self::advance(current, input, diags);
                                }
                            }
                        }
                    })?;
                }
                Token::Semi if !lelwel_is_first => break,
                _ if lelwel_is_first => return err![input, "<identifier>"],
                _ => return err![input, "<identifier>", ";"],
            }
            lelwel_is_first = false;
        }
        let r#Semi = consume!(Semi, ";", current, input, diags);
        // semantic action 5
        Ok(())
    }
    fn r#rule_or_action(
        lelwel_depth: u64,
        current: &mut Token<'a>,
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
        interner: &mut StringInterner<'a>,
        module: &mut Module<'a>,
    ) -> Result<(), Diagnostic> {
        check_limit!(input, current, lelwel_depth);
        // semantic action 0
        enum ElemType {
            Action,
            Predicate,
            ErrorHandler,
        }
        let name;
        let name_span;
        let mut ret = "";
        let mut pars = "";
        let elem_type;
        let num;
        let doc = std::mem::take(&mut input.last_doc_comment);
        let mut rule_regex = None;
        match current {
            Token::Id(..) => {
                let r#Id = consume!(Id, "<identifier>", current, input, diags, _);
                // semantic action 1
                name = interner.get(Id.0);
                name_span = Id.1;
            }
            Token::Start => {
                let r#Start = consume!(Start, "start", current, input, diags);
                // semantic action 2
                name = symbols::START;
                name_span = Start;
            }
            _ => return err![input, "<identifier>", "start"],
        }
        match current {
            Token::Code(..) | Token::Colon => {
                match current {
                    Token::Code(..) => {
                        let r#Code = consume!(Code, "<code segment>", current, input, diags, _);
                        // semantic action 3
                        ret = Code.0;
                        match current {
                            Token::Code(..) => {
                                let r#Code =
                                    consume!(Code, "<code segment>", current, input, diags, _);
                                // semantic action 4
                                pars = Code.0;
                            }
                            Token::Colon => {}
                            _ => return err![input, "<code segment>", ":"],
                        }
                    }
                    Token::Colon => {}
                    _ => return err![input, "<code segment>", ":"],
                }
                let r#Colon = consume!(Colon, ":", current, input, diags);
                match current {
                    Token::Action(..)
                    | Token::ErrorHandler(..)
                    | Token::Id(..)
                    | Token::LBrak
                    | Token::LPar
                    | Token::Predicate(..)
                    | Token::Str(..) => {
                        (|| {
                            match current {
                                Token::Action(..)
                                | Token::ErrorHandler(..)
                                | Token::Id(..)
                                | Token::LBrak
                                | Token::LPar
                                | Token::Predicate(..)
                                | Token::Str(..) => {
                                    let r#regex = Self::r#regex(
                                        lelwel_depth + 1,
                                        current,
                                        input,
                                        diags,
                                        interner,
                                        module,
                                        name,
                                    )?;
                                    // semantic action 5
                                    rule_regex = Some(regex);
                                    Ok(())
                                }
                                _ => {
                                    return err![
                                        input,
                                        "<semantic action>",
                                        "<error handler>",
                                        "<identifier>",
                                        "[",
                                        "(",
                                        "<semantic predicate>",
                                        "<string literal>"
                                    ]
                                }
                            }
                        })()
                        .or_else(|diagnostic| {
                            // error handling
                            loop {
                                match current {
                                    Token::Semi => {
                                        // error handler 1
                                        rule_regex = Some(Regex::new_invalid(module, &name_span));
                                        diags.push(diagnostic);
                                        return Ok::<(), Diagnostic>(());
                                    }
                                    Token::EOF
                                    | Token::Id(..)
                                    | Token::Pars
                                    | Token::Start
                                    | Token::Token => return Err(diagnostic),
                                    _ => {
                                        Self::advance(current, input, diags);
                                    }
                                }
                            }
                        })?;
                    }
                    Token::Semi => {}
                    _ => {
                        return err![
                            input,
                            "<semantic action>",
                            "<error handler>",
                            "<identifier>",
                            "[",
                            "(",
                            "<semantic predicate>",
                            ";",
                            "<string literal>"
                        ]
                    }
                }
                let r#Semi = consume!(Semi, ";", current, input, diags);
                // semantic action 6
                let span = name_span.start..Semi.end;
                let regex = rule_regex.unwrap_or_else(|| Regex::new_empty(module, &span));
                if name == symbols::START {
                    Element::new_start(module, ret, pars, regex, &span, doc);
                } else {
                    Element::new_rule(module, name, name_span, ret, pars, regex, &span, doc);
                }
                Ok(())
            }
            Token::Action(..) | Token::ErrorHandler(..) | Token::Predicate(..) => {
                match current {
                    Token::Action(..) => {
                        let r#Action =
                            consume!(Action, "<semantic action>", current, input, diags, _);
                        // semantic action 7
                        elem_type = ElemType::Action;
                        num = Action.0;
                    }
                    Token::Predicate(..) => {
                        let r#Predicate =
                            consume!(Predicate, "<semantic predicate>", current, input, diags, _);
                        // semantic action 8
                        elem_type = ElemType::Predicate;
                        num = Predicate.0;
                    }
                    Token::ErrorHandler(..) => {
                        let r#ErrorHandler =
                            consume!(ErrorHandler, "<error handler>", current, input, diags, _);
                        // semantic action 9
                        elem_type = ElemType::ErrorHandler;
                        num = ErrorHandler.0;
                    }
                    _ => {
                        return err![
                            input,
                            "<semantic action>",
                            "<error handler>",
                            "<semantic predicate>"
                        ]
                    }
                }
                let r#Code = consume!(Code, "<code segment>", current, input, diags, _);
                // semantic action 10
                let span = name_span.start..Code.1.end;
                match elem_type {
                    ElemType::Action => {
                        Element::new_action(module, name, &name_span, num, Code.0, &span, doc)
                    }
                    ElemType::Predicate => {
                        Element::new_predicate(module, name, &name_span, num, Code.0, &span, doc)
                    }
                    ElemType::ErrorHandler => Element::new_error_handler(
                        module, name, &name_span, num, Code.0, &span, doc,
                    ),
                };
                Ok(())
            }
            _ => {
                return err![
                    input,
                    "<semantic action>",
                    "<code segment>",
                    ":",
                    "<error handler>",
                    "<semantic predicate>"
                ]
            }
        }
    }
    fn r#regex(
        lelwel_depth: u64,
        current: &mut Token<'a>,
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
        interner: &mut StringInterner<'a>,
        module: &mut Module<'a>,
        name: Symbol<'a>,
    ) -> Result<RegexRef, Diagnostic> {
        check_limit!(input, current, lelwel_depth);
        let r#concat = Self::r#concat(
            lelwel_depth + 1,
            current,
            input,
            diags,
            interner,
            module,
            name,
        )?;
        // semantic action 1
        let mut regexes = vec![concat];
        loop {
            match current {
                Token::Or => {
                    let r#Or = consume!(Or, "|", current, input, diags);
                    let r#concat = Self::r#concat(
                        lelwel_depth + 1,
                        current,
                        input,
                        diags,
                        interner,
                        module,
                        name,
                    )?;
                    // semantic action 2
                    regexes.push(concat);
                }
                Token::RBrak | Token::RPar | Token::Semi => break,
                _ => return err![input, "|", "]", ")", ";"],
            }
        }
        // semantic action 3
        let span = module.get_regex(concat).unwrap().span.start
            ..module.get_regex(*regexes.last().unwrap()).unwrap().span.end;
        if regexes.len() > 1 {
            Ok(Regex::new_or(module, regexes, &span))
        } else {
            Ok(regexes[0])
        }
    }
    fn r#concat(
        lelwel_depth: u64,
        current: &mut Token<'a>,
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
        interner: &mut StringInterner<'a>,
        module: &mut Module<'a>,
        name: Symbol<'a>,
    ) -> Result<RegexRef, Diagnostic> {
        check_limit!(input, current, lelwel_depth);
        // semantic action 0
        let mut regexes = Vec::new();
        let mut lelwel_is_first = true;
        loop {
            match current {
                Token::Action(..)
                | Token::ErrorHandler(..)
                | Token::Id(..)
                | Token::LBrak
                | Token::LPar
                | Token::Predicate(..)
                | Token::Str(..) => {
                    let r#postfix = Self::r#postfix(
                        lelwel_depth + 1,
                        current,
                        input,
                        diags,
                        interner,
                        module,
                        name,
                    )?;
                    // semantic action 1
                    regexes.push(postfix);
                }
                Token::Or | Token::RBrak | Token::RPar | Token::Semi if !lelwel_is_first => break,
                _ if lelwel_is_first => {
                    return err![
                        input,
                        "<semantic action>",
                        "<error handler>",
                        "<identifier>",
                        "[",
                        "(",
                        "<semantic predicate>",
                        "<string literal>"
                    ]
                }
                _ => {
                    return err![
                        input,
                        "<semantic action>",
                        "<error handler>",
                        "<identifier>",
                        "[",
                        "(",
                        "<semantic predicate>",
                        "<string literal>",
                        "|",
                        "]",
                        ")",
                        ";"
                    ]
                }
            }
            lelwel_is_first = false;
        }
        // semantic action 2
        let span = module.get_regex(regexes[0]).unwrap().span.start
            ..module.get_regex(*regexes.last().unwrap()).unwrap().span.end;
        if regexes.len() > 1 {
            Ok(Regex::new_concat(module, regexes, &span))
        } else {
            Ok(regexes[0])
        }
    }
    fn r#postfix(
        lelwel_depth: u64,
        current: &mut Token<'a>,
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
        interner: &mut StringInterner<'a>,
        module: &mut Module<'a>,
        name: Symbol<'a>,
    ) -> Result<RegexRef, Diagnostic> {
        check_limit!(input, current, lelwel_depth);
        // semantic action 0
        let mut regex = None;
        let mut span = input.span();
        (|| {
            match current {
                Token::Action(..)
                | Token::ErrorHandler(..)
                | Token::Id(..)
                | Token::LBrak
                | Token::LPar
                | Token::Predicate(..)
                | Token::Str(..) => {
                    let r#atomic = Self::r#atomic(
                        lelwel_depth + 1,
                        current,
                        input,
                        diags,
                        interner,
                        module,
                        name,
                    )?;
                    // semantic action 1
                    regex = Some(atomic);
                    span = module.get_regex(atomic).unwrap().span.clone();
                    loop {
                        match current {
                            Token::Plus | Token::Star => {
                                match current {
                                    Token::Star => {
                                        let r#Star = consume!(Star, "*", current, input, diags);
                                        // semantic action 2
                                        span = span.start..Star.end;
                                        regex =
                                            Some(Regex::new_star(module, regex.unwrap(), &span));
                                    }
                                    Token::Plus => {
                                        let r#Plus = consume!(Plus, "+", current, input, diags);
                                        // semantic action 3
                                        span = span.start..Plus.end;
                                        regex =
                                            Some(Regex::new_plus(module, regex.unwrap(), &span));
                                    }
                                    _ => return err![input, "+", "*"],
                                }
                            }
                            Token::Action(..)
                            | Token::ErrorHandler(..)
                            | Token::Id(..)
                            | Token::LBrak
                            | Token::LPar
                            | Token::Or
                            | Token::Predicate(..)
                            | Token::RBrak
                            | Token::RPar
                            | Token::Semi
                            | Token::Str(..) => break,
                            _ => {
                                return err![
                                    input,
                                    "<semantic action>",
                                    "<error handler>",
                                    "<identifier>",
                                    "[",
                                    "(",
                                    "|",
                                    "+",
                                    "<semantic predicate>",
                                    "]",
                                    ")",
                                    ";",
                                    "*",
                                    "<string literal>"
                                ]
                            }
                        }
                    }
                    Ok(())
                }
                _ => {
                    return err![
                        input,
                        "<semantic action>",
                        "<error handler>",
                        "<identifier>",
                        "[",
                        "(",
                        "<semantic predicate>",
                        "<string literal>"
                    ]
                }
            }
        })()
        .or_else(|diagnostic| {
            // error handling
            loop {
                match current {
                    Token::Action(..)
                    | Token::ErrorHandler(..)
                    | Token::Id(..)
                    | Token::LBrak
                    | Token::LPar
                    | Token::Or
                    | Token::Predicate(..)
                    | Token::RBrak
                    | Token::RPar
                    | Token::Semi
                    | Token::Str(..) => {
                        // error handler 1
                        diags.push(diagnostic);
                        return Ok::<(), Diagnostic>(());
                    }
                    Token::EOF | Token::Pars | Token::Start | Token::Token => {
                        return Err(diagnostic)
                    }
                    _ => {
                        Self::advance(current, input, diags);
                    }
                }
            }
        })?;
        // semantic action 4
        Ok(regex.unwrap_or_else(|| Regex::new_invalid(module, &span)))
    }
    fn r#atomic(
        lelwel_depth: u64,
        current: &mut Token<'a>,
        input: &mut TokenStream<'a>,
        diags: &mut Vec<Diagnostic>,
        interner: &mut StringInterner<'a>,
        module: &mut Module<'a>,
        name: Symbol<'a>,
    ) -> Result<RegexRef, Diagnostic> {
        check_limit!(input, current, lelwel_depth);
        match current {
            Token::Id(..) => {
                let r#Id = consume!(Id, "<identifier>", current, input, diags, _);
                // semantic action 1
                Ok(Regex::new_id(module, interner.get(Id.0), &Id.1))
            }
            Token::Str(..) => {
                let r#Str = consume!(Str, "<string literal>", current, input, diags, _);
                // semantic action 2
                Ok(Regex::new_str(module, interner.get(Str.0), &Str.1))
            }
            Token::Predicate(..) => {
                let r#Predicate =
                    consume!(Predicate, "<semantic predicate>", current, input, diags, _);
                // semantic action 3
                Ok(Regex::new_predicate(
                    module,
                    name,
                    Predicate.0,
                    &Predicate.1,
                ))
            }
            Token::Action(..) => {
                let r#Action = consume!(Action, "<semantic action>", current, input, diags, _);
                // semantic action 4
                Ok(Regex::new_action(module, name, Action.0, &Action.1))
            }
            Token::ErrorHandler(..) => {
                let r#ErrorHandler =
                    consume!(ErrorHandler, "<error handler>", current, input, diags, _);
                // semantic action 5
                Ok(Regex::new_error_handler(
                    module,
                    name,
                    ErrorHandler.0,
                    &ErrorHandler.1,
                ))
            }
            Token::LPar => {
                let r#LPar = consume!(LPar, "(", current, input, diags);
                let r#regex = Self::r#regex(
                    lelwel_depth + 1,
                    current,
                    input,
                    diags,
                    interner,
                    module,
                    name,
                )?;
                let r#RPar = consume!(RPar, ")", current, input, diags);
                // semantic action 6
                let span = LPar.start..RPar.end;
                Ok(Regex::new_paren(module, regex, &span))
            }
            Token::LBrak => {
                let r#LBrak = consume!(LBrak, "[", current, input, diags);
                let r#regex = Self::r#regex(
                    lelwel_depth + 1,
                    current,
                    input,
                    diags,
                    interner,
                    module,
                    name,
                )?;
                let r#RBrak = consume!(RBrak, "]", current, input, diags);
                // semantic action 7
                let span = LBrak.start..RBrak.end;
                Ok(Regex::new_option(module, regex, &span))
            }
            _ => {
                return err![
                    input,
                    "<semantic action>",
                    "<error handler>",
                    "<identifier>",
                    "[",
                    "(",
                    "<semantic predicate>",
                    "<string literal>"
                ]
            }
        }
    }
}
