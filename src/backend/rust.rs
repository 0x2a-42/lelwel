use crate::frontend::ast::*;
use crate::frontend::symbols::{self, Symbol};
use crate::VERSION;
use std::collections::HashMap;
use std::fs::*;
use std::io::Write;
use std::path::Path;

trait Indent {
    fn indent(&self, level: usize) -> String;
}

impl Indent for &str {
    fn indent(&self, level: usize) -> String {
        let mut result = String::new();
        for l in self.lines() {
            if l.is_empty() {
                continue;
            }
            result.push_str(&"    ".repeat(level));
            result.push_str(l);
            result.push('\n');
        }
        if !self.ends_with('\n') {
            result.pop();
        }
        result
    }
}

impl Indent for String {
    fn indent(&self, level: usize) -> String {
        self.as_str().indent(level)
    }
}

trait Generator {
    fn pattern(&self, level: usize, token_pattern: &HashMap<Symbol, &str>) -> String;
    fn error(&self, level: usize, token_symbols: &HashMap<Symbol, &str>) -> String;
}

impl<'a> Generator for std::collections::BTreeSet<Symbol<'a>> {
    fn pattern(&self, level: usize, token_pattern: &HashMap<Symbol, &str>) -> String {
        if !self.is_empty() {
            let symbols: Vec<_> = self
                .iter()
                .map(|s| format!("Token::{}{}", s, token_pattern.get(s).unwrap_or(&"")))
                .collect();
            symbols.join(&format!("\n{}| ", "    ".repeat(level)))
        } else {
            "Token::EOF".to_string()
        }
    }
    fn error(&self, level: usize, token_symbols: &HashMap<Symbol, &str>) -> String {
        if !self.is_empty() {
            let symbols: Vec<_> = self
                .iter()
                .map(|s| format!("\"{}\"", token_symbols[s]))
                .collect();
            symbols.join(&format!(",\n{}", "    ".repeat(level)))
        } else {
            "EOF".to_string()
        }
    }
}

impl<'a> Symbol<'a> {
    fn get_content(&self, alternative: &'a str) -> &'a str {
        if self.0.is_empty() || *self == symbols::EMPTY {
            alternative
        } else {
            &self.0[1..self.0.len() - 1]
        }
    }
}

pub struct RustOutput {}

impl RustOutput {
    pub fn create(module: &Module, input: &Path, output: &Path) -> std::io::Result<()> {
        let parser_path = input.parent().unwrap().join("parser.rs");
        if !parser_path.exists() {
            Self::output_parser(module, &parser_path)?;
        }

        let mut file = File::create(output.join("generated.rs"))?;
        file.write_all(format!("// generated by lelwel {}\n\n", VERSION).as_bytes())?;

        Self::output_consumes(&mut file)?;
        Self::output_generated(module, &mut file)
    }

    fn output_parser(module: &Module, path: &Path) -> std::io::Result<()> {
        let mut file = File::create(path)?;

        let mut token_enumerators = "{\n    EOF,\n".to_string();
        let mut token_type = "Token";
        for element in module.elements.iter() {
            if let ElementKind::Token { name, ty, sym } = element.kind {
                if !(sym.0.is_empty()
                    || sym == symbols::EMPTY
                    || sym.0.starts_with("'<") && sym.0.ends_with(">'") && sym.0.len() > 4)
                {
                    token_enumerators += "    #[token(\"";
                    token_enumerators += &sym.0[1..sym.0.len() - 1];
                    token_enumerators += "\")]\n";
                }
                token_enumerators += "    ";
                token_enumerators += name.0;
                if !ty.is_empty() {
                    token_enumerators += "(";
                    token_enumerators += ty;
                    token_enumerators += "),\n";
                } else {
                    token_enumerators += ",\n";
                }
                if !ty.is_empty() && ty.contains("'a") {
                    token_type = "Token<'a>";
                }
            }
        }

        let template = include_str!("parser_template.rs")
            .replace("{\n    EOF,\n", &token_enumerators)
            .replace("Token<'a>", token_type);

        file.write_all(template.as_bytes())
    }

    #[allow(clippy::too_many_arguments)]
    fn output_element(
        module: &Module,
        element: &Element,
        output: &mut File,
        common_pars: &str,
        common_args: &str,
        token_pattern: &HashMap<Symbol, &str>,
        token_symbols: &HashMap<Symbol, &str>,
        token_lifetime: &str,
    ) -> std::io::Result<()> {
        if !element.used {
            return Ok(());
        }
        let mut is_acceptor = true;
        match element.kind {
            ElementKind::Start {
                ret,
                pars,
                regex,
                action,
            } => {
                let pars = if pars.is_empty() {
                    "".to_string()
                } else {
                    format!(", {}", pars)
                };
                let ret = if ret.is_empty() {
                    "()".to_string()
                } else {
                    ret.to_string()
                };
                output.write_all(
                    format!(
                        "    fn start(current: &mut Token{token_lifetime}, input: &mut TokenStream<'a>, diags: &mut Vec<Diagnostic>{common_pars}{pars}) -> Result<{ret}, Diagnostic> {{\
                       \n        let lelwel_depth = 0;\n",
                    )
                    .as_bytes(),
                )?;
                if let Some(Element {
                    kind: ElementKind::Action { code, .. },
                    ..
                }) = module.get_element(action)
                {
                    let code = if code.contains('\n') {
                        code.to_string()
                    } else {
                        "    ".to_string() + code.trim()
                    };
                    output.write_all(
                        format!("    // semantic action start#0\n{code}\n")
                            .indent(1)
                            .as_bytes(),
                    )?;
                }
                Self::output_regex(
                    module,
                    module.get_regex(regex).unwrap(),
                    output,
                    common_args,
                    2,
                    token_pattern,
                    token_symbols,
                    token_lifetime,
                    &mut is_acceptor,
                )?;
            }
            ElementKind::Rule {
                name,
                ret,
                pars,
                regex,
                action,
                ..
            } => {
                let pars = if pars.is_empty() {
                    "".to_string()
                } else {
                    format!(", {}", pars)
                };
                let ret = if ret.is_empty() {
                    "()".to_string()
                } else {
                    ret.to_string()
                };
                output.write_all(
                    format!(
                        "    fn r#{name}(lelwel_depth: u64, current: &mut Token{token_lifetime}, input: &mut TokenStream<'a>, diags: &mut Vec<Diagnostic>{common_pars}{pars}) -> Result<{ret}, Diagnostic> {{\n",
                    )
                    .as_bytes()
                )?;

                output.write_all(
                    "check_limit!(input, current, lelwel_depth);\n"
                        .indent(2)
                        .as_bytes(),
                )?;

                if let Some(Element {
                    kind: ElementKind::Action { code, .. },
                    ..
                }) = module.get_element(action)
                {
                    let code = if code.contains('\n') {
                        code.to_string()
                    } else {
                        "    ".to_string() + code.trim()
                    };
                    output.write_all(
                        format!("    // semantic action {name}#0\n{code}\n")
                            .indent(1)
                            .as_bytes(),
                    )?;
                }
                Self::output_regex(
                    module,
                    module.get_regex(regex).unwrap(),
                    output,
                    common_args,
                    2,
                    token_pattern,
                    token_symbols,
                    token_lifetime,
                    &mut is_acceptor,
                )?;
            }
            _ => {
                return Ok(());
            }
        }
        if is_acceptor {
            output.write_all(b"        Ok(())\n")?;
        }
        output.write_all(b"    }\n")?;
        Ok(())
    }

    fn get_predicate(module: &Module, regex: &Regex) -> String {
        match regex.kind {
            RegexKind::Concat { ref ops, .. } => match module.get_regex(ops[0]).unwrap().kind {
                RegexKind::Predicate { elem, .. } => {
                    if let Some(Element {
                        kind: ElementKind::Predicate { code, .. },
                        ..
                    }) = module.get_element(elem)
                    {
                        format!(" if {}", code.to_string().trim())
                    } else {
                        "".to_string()
                    }
                }
                _ => "".to_string(),
            },
            RegexKind::Paren { op } => Self::get_predicate(module, module.get_regex(op).unwrap()),
            _ => "".to_string(),
        }
    }

    #[allow(clippy::too_many_arguments)]
    fn output_error_handler(
        module: &Module,
        error: &Regex,
        output: &mut File,
        common_args: &str,
        level: usize,
        token_pattern: &HashMap<Symbol, &str>,
        token_symbols: &HashMap<Symbol, &str>,
        token_lifetime: &str,
        is_acceptor: &mut bool,
    ) -> std::io::Result<()> {
        output.write_all(
            format!(
                "}})().or_else(|diagnostic| {{\
               \n    // error handling\
               \n    loop {{\
               \n        match current {{\
               \n            {} => {{\n",
                error.follow.pattern(3, token_pattern),
            )
            .indent(level - 1)
            .as_bytes(),
        )?;
        Self::output_regex(
            module,
            error,
            output,
            common_args,
            level + 3,
            token_pattern,
            token_symbols,
            token_lifetime,
            is_acceptor,
        )?;
        output.write_all(
            "                return Ok::<(), Diagnostic>(());\
           \n            }\n"
                .indent(level - 1)
                .as_bytes(),
        )?;
        if !error.cancel.is_empty() {
            output.write_all(
                format!(
                    "            {} => {{\
                   \n                return Err(diagnostic)\
                   \n            }}\n",
                    error.cancel.pattern(3, token_pattern),
                )
                .indent(level - 1)
                .as_bytes(),
            )?;
        }
        output.write_all(
            "            _ => {\
           \n                Self::advance(current, input, diags);\
           \n            }\
           \n       }\
           \n   }\
           \n})?;\n"
                .indent(level - 1)
                .as_bytes(),
        )
    }

    #[allow(clippy::too_many_arguments)]
    fn output_regex(
        module: &Module,
        regex: &Regex,
        output: &mut File,
        common_args: &str,
        level: usize,
        token_pattern: &HashMap<Symbol, &str>,
        token_symbols: &HashMap<Symbol, &str>,
        token_lifetime: &str,
        is_acceptor: &mut bool,
    ) -> std::io::Result<()> {
        match regex.kind {
            RegexKind::Id { name, elem } => match module.get_element(elem).unwrap().kind {
                ElementKind::Rule { pars, .. } => {
                    let args = Self::par_to_arg(pars);
                    let args = if args.is_empty() {
                        "".to_string()
                    } else if common_args.is_empty() {
                        args
                    } else {
                        format!(", {}", args)
                    };
                    output.write_all(
                        format!(
                            "let r#{name} = Self::r#{name}(lelwel_depth + 1, current, input, diags{common_args}{args})?;\n",
                        )
                        .indent(level)
                        .as_bytes(),
                    )?;
                }
                ElementKind::Token { name, ty, sym } => {
                    output.write_all(
                        format!(
                            "let r#{name} = consume!({name}, \"{}\", current, input, diags{});\n",
                            sym.get_content(name.0),
                            if ty.is_empty() { "" } else { ", _" }
                        )
                        .indent(level)
                        .as_bytes(),
                    )?;
                }
                _ => unreachable!(),
            },
            RegexKind::Str { elem, .. } => match module.get_element(elem).unwrap().kind {
                ElementKind::Token { name, ty, sym } => {
                    output.write_all(
                        format!(
                            "let r#{name} = consume!({name}, \"{}\", current, input, diags{});\n",
                            &sym.0[1..sym.0.len() - 1],
                            if ty.is_empty() { "" } else { ", _" }
                        )
                        .indent(level)
                        .as_bytes(),
                    )?;
                }
                _ => unreachable!(),
            },
            RegexKind::Concat { ref ops, error } => {
                let level = if module.get_regex(error).is_some() {
                    output.write_all("(|| {\n".indent(level).as_bytes())?;
                    level + 1
                } else {
                    level
                };
                for op in ops {
                    let op = module.get_regex(*op).unwrap();
                    if let RegexKind::ErrorHandler { .. } = op.kind {
                        output.write_all(
                            format!(
                                "match current {{\
                               \n    {} => {{\
                               \n        Ok(())\
                               \n    }}\
                               \n    _ => {{\
                               \n        return err![input, {}]\
                               \n    }}\
                               \n}}\n",
                                op.follow.pattern(1, token_pattern),
                                op.follow.error(5, token_symbols)
                            )
                            .indent(level)
                            .as_bytes(),
                        )?;
                    } else {
                        Self::output_regex(
                            module,
                            op,
                            output,
                            common_args,
                            level,
                            token_pattern,
                            token_symbols,
                            token_lifetime,
                            is_acceptor,
                        )?;
                    }
                }
                if let Some(error) = module.get_regex(error) {
                    Self::output_error_handler(
                        module,
                        error,
                        output,
                        common_args,
                        level,
                        token_pattern,
                        token_symbols,
                        token_lifetime,
                        is_acceptor,
                    )?;
                }
            }
            RegexKind::Or { ref ops, error } => {
                let level = if module.get_regex(error).is_some() {
                    output.write_all("(|| {\n".indent(level).as_bytes())?;
                    level + 1
                } else {
                    level
                };
                output.write_all("match current {\n".indent(level).as_bytes())?;
                for op in ops {
                    let op = module.get_regex(*op).unwrap();
                    // check if this is the error rule, if so ignore it here
                    if let RegexKind::ErrorHandler { .. } = &op.kind {
                        continue;
                    }
                    output.write_all(
                        format!(
                            "{}{} => {{\n",
                            op.predict().pattern(0, token_pattern),
                            Self::get_predicate(module, op)
                        )
                        .indent(level + 1)
                        .as_bytes(),
                    )?;
                    Self::output_regex(
                        module,
                        op,
                        output,
                        common_args,
                        level + 2,
                        token_pattern,
                        token_symbols,
                        token_lifetime,
                        is_acceptor,
                    )?;
                    if module.get_regex(error).is_some() {
                        output.write_all("Ok(())\n".indent(level + 2).as_bytes())?;
                    }
                    output.write_all("}\n".indent(level + 1).as_bytes())?;
                }
                output.write_all(
                    format!(
                        "    _ => {{\
                       \n        return err![input, {}]\
                       \n    }}\
                       \n}}\n",
                        regex.predict().error(5, token_symbols)
                    )
                    .indent(level)
                    .as_bytes(),
                )?;
                if let Some(error) = module.get_regex(error) {
                    Self::output_error_handler(
                        module,
                        error,
                        output,
                        common_args,
                        level,
                        token_pattern,
                        token_symbols,
                        token_lifetime,
                        is_acceptor,
                    )?;
                }
            }
            RegexKind::Star { op } => {
                let op = module.get_regex(op).unwrap();
                output.write_all(
                    format!(
                        "loop {{\
                       \n    match current {{\
                       \n        {}{} => {{\n",
                        op.first.pattern(2, token_pattern),
                        Self::get_predicate(module, op)
                    )
                    .indent(level)
                    .as_bytes(),
                )?;
                Self::output_regex(
                    module,
                    op,
                    output,
                    common_args,
                    level + 3,
                    token_pattern,
                    token_symbols,
                    token_lifetime,
                    is_acceptor,
                )?;
                output.write_all(
                    format!(
                        "        }}\
                       \n        {} => break,\
                       \n        _ => {{\
                       \n            return err![input, {}]\
                       \n        }}\
                       \n    }}\
                       \n}}\n",
                        regex.follow.pattern(2, token_pattern),
                        regex.predict().error(6, token_symbols)
                    )
                    .indent(level)
                    .as_bytes(),
                )?;
            }
            RegexKind::Plus { op } => {
                let op = module.get_regex(op).unwrap();
                output.write_all(
                    format!(
                        "let mut lelwel_is_first = true;\
                       \nloop {{\
                       \n    match current {{\
                       \n        {}{} => {{\n",
                        op.first.pattern(2, token_pattern),
                        Self::get_predicate(module, op),
                    )
                    .indent(level)
                    .as_bytes(),
                )?;
                Self::output_regex(
                    module,
                    op,
                    output,
                    common_args,
                    level + 3,
                    token_pattern,
                    token_symbols,
                    token_lifetime,
                    is_acceptor,
                )?;
                output.write_all(
                    format!(
                        "        }}\
                       \n        {0} if !lelwel_is_first => break,\
                       \n        _ if lelwel_is_first => {{\
                       \n            return err![input, {1}]\
                       \n        }}\
                       \n        _ => {{\
                       \n            return err![input,\
                       \n                        {1},\
                       \n                        {2}]\
                       \n        }}\
                       \n    }}\
                       \n    lelwel_is_first = false;\
                       \n}}\n",
                        regex.follow.pattern(2, token_pattern),
                        regex.first.error(6, token_symbols),
                        regex.follow.error(6, token_symbols)
                    )
                    .indent(level)
                    .as_bytes(),
                )?;
            }
            RegexKind::Option { op } => {
                let op = module.get_regex(op).unwrap();
                let name = match op.kind {
                    RegexKind::Id { name, .. } => name,
                    RegexKind::Str { elem, .. } => match module.get_element(elem) {
                        Some(Element {
                            kind: ElementKind::Token { name, .. },
                            ..
                        }) => *name,
                        _ => symbols::EMPTY,
                    },
                    _ => symbols::EMPTY,
                };
                output.write_all(
                    format!(
                        "{}match current {{\
                       \n    {}{} => {{\n",
                        if name != symbols::EMPTY {
                            format!("let r#{name} = ")
                        } else {
                            "".to_string()
                        },
                        op.first.pattern(1, token_pattern),
                        Self::get_predicate(module, op)
                    )
                    .indent(level)
                    .as_bytes(),
                )?;
                Self::output_regex(
                    module,
                    op,
                    output,
                    common_args,
                    level + 2,
                    token_pattern,
                    token_symbols,
                    token_lifetime,
                    is_acceptor,
                )?;
                if name != symbols::EMPTY {
                    output.write_all(format!("Some({name})\n").indent(level + 2).as_bytes())?;
                }
                output.write_all(
                    format!(
                        "    }}\
                       \n    {} => {}\
                       \n    _ => {{\
                       \n        return err![input, {}]\
                       \n    }}\
                       \n}}{}\n",
                        regex.follow.pattern(1, token_pattern),
                        if name != symbols::EMPTY {
                            "None,"
                        } else {
                            "{}"
                        },
                        regex.predict().error(5, token_symbols),
                        if name != symbols::EMPTY { ";" } else { "" },
                    )
                    .indent(level)
                    .as_bytes(),
                )?;
            }
            RegexKind::Paren { op } => {
                Self::output_regex(
                    module,
                    module.get_regex(op).unwrap(),
                    output,
                    common_args,
                    level,
                    token_pattern,
                    token_symbols,
                    token_lifetime,
                    is_acceptor,
                )?;
            }
            RegexKind::Action {
                val,
                elem,
                rule_name,
            } => {
                *is_acceptor = false;
                let code = match module.get_element(elem) {
                    Some(Element {
                        kind: ElementKind::Action { code, .. },
                        ..
                    }) => {
                        if code.contains('\n') {
                            code.to_string()
                        } else {
                            "    ".to_string() + code.trim()
                        }
                    }
                    _ => format!("    todo!(\"semantic action {rule_name}#{val}\");\n"),
                };
                output.write_all(
                    format!("    // semantic action {rule_name}#{val}\n{code}\n")
                        .indent(level - 1)
                        .as_bytes(),
                )?;
            }
            RegexKind::ErrorHandler {
                val,
                elem,
                rule_name,
            } => {
                let label = if val == u64::MAX {
                    "default error handler".to_string()
                } else {
                    format!("error handler {rule_name}!{val}")
                };
                let code = match module.get_element(elem) {
                    Some(Element {
                        kind: ElementKind::ErrorHandler { code, .. },
                        ..
                    }) => {
                        if code.contains('\n') {
                            code.to_string()
                        } else {
                            "    ".to_string() + code.trim()
                        }
                    }
                    _ => {
                        if val == u64::MAX {
                            "    diags.push(diagnostic);".to_string()
                        } else {
                            format!("    todo!(\"error handler {rule_name}!{val}\");\n")
                        }
                    }
                };
                output.write_all(
                    format!("    // {label}\n{code}\n")
                        .indent(level - 1)
                        .as_bytes(),
                )?;
            }
            _ => {}
        }
        Ok(())
    }

    /// Outputs the consume macro.
    fn output_consumes(output: &mut File) -> std::io::Result<()> {
        output.write_all(
            b"macro_rules! consume {\
            \n    ($tok:ident, $sym:literal, $current:expr, $input:expr, $diags:expr) => {{\
            \n        let span = $input.span();\
            \n        if let Token::$tok = $current {\
            \n            Self::advance($current, $input, $diags);\
            \n            span\
            \n        } else {\
            \n            return err![$input, $sym];\
            \n        }\
            \n    }};\
            \n    ($tok:ident, $sym:literal, $current:expr, $input:expr, $diags:expr, _) => {{\
            \n        let span = $input.span();\
            \n        if let Token::$tok(..) = $current {\
            \n            if let Token::$tok(val) = Self::advance($current, $input, $diags) {\
            \n                (val, span)\
            \n            } else {\
            \n                unreachable!()\
            \n            }\
            \n        } else {\
            \n            return err![$input, $sym];\
            \n        }\
            \n    }};\
            \n}\n\n",
        )
    }

    /// Outputs the Parser struct and impl.
    fn output_generated(module: &Module, output: &mut File) -> std::io::Result<()> {
        let common_pars = match module.get_element(module.parameters) {
            Some(Element {
                kind: ElementKind::Parameters { code },
                ..
            }) => {
                format!(", {}", code.to_string().trim())
            }
            _ => "".to_string(),
        };
        let common_args = match module.get_element(module.parameters) {
            Some(Element {
                kind: ElementKind::Parameters { code },
                ..
            }) => {
                format!(", {}", Self::par_to_arg(code.to_string().trim()))
            }
            _ => "".to_string(),
        };
        let mut start_ret = "()".to_string();
        let mut start_pars = "".to_string();
        for element in module.elements.iter() {
            if let ElementKind::Start { ret, pars, .. } = element.kind {
                if !ret.is_empty() {
                    start_ret = ret.to_string()
                }
                if !pars.is_empty() {
                    start_pars = format!(", {}", pars)
                }
            }
        }
        let mut token_symbols = HashMap::from([(symbols::EOF, "<end of file>")]);
        let mut token_pattern = HashMap::new();
        let mut token_lifetime = "";
        for element in module.elements.iter() {
            if let ElementKind::Token { name, ty, sym } = element.kind {
                token_symbols.insert(name, sym.get_content(name.0));
                if !ty.is_empty() {
                    token_pattern.insert(name, "(..)");
                    if ty.contains("'a") {
                        token_lifetime = "<'a>";
                    }
                }
            }
        }

        output.write_all(
            format!(
                "pub struct Parser;\
               \n\
               \n#[allow(\
               \n    clippy::needless_return,\
               \n    clippy::let_unit_value,\
               \n    non_snake_case,\
               \n    unused\
               \n)]\
               \nimpl<'a> Parser {{\
               \n    fn advance(current: &mut Token{token_lifetime}, input: &mut TokenStream<'a>, diags: &mut Vec<Diagnostic>) -> Token{token_lifetime} {{\
               \n        loop {{\
               \n            match input.next_token() {{\
               \n                Ok(tok) => {{\
               \n                    return std::mem::replace(current, tok);\
               \n                }}\
               \n                Err(err) => {{\
               \n                    diags.push(err.into_diagnostic(input.span()));\
               \n                }}\
               \n            }}\
               \n        }}\
               \n    }}\
               \n    pub fn parse(input: &mut TokenStream<'a>, diags: &mut Vec<Diagnostic>{common_pars}{start_pars}) -> Option<{start_ret}> {{\
               \n        let mut current = Token::EOF;\
               \n        let current = &mut current;\
               \n        Self::advance(current, input, diags);\
               \n        let out = match Self::start(current, input, diags{common_args}) {{\
               \n            Ok(out) => Some(out),\
               \n            Err(diag) => {{\
               \n                diags.push(diag);\
               \n                *current = Token::EOF;\
               \n                None\
               \n            }}\
               \n        }};\
               \n        if *current != Token::EOF {{\
               \n            let err: Result<(), Diagnostic> = err![input, \"<end of file>\"];\
               \n            diags.push(err.unwrap_err());\
               \n        }}\
               \n        out\
               \n    }}\n",
            )
            .as_bytes(),
        )?;
        for element in module.elements.iter() {
            Self::output_element(
                module,
                element,
                output,
                &common_pars,
                &common_args,
                &token_pattern,
                &token_symbols,
                token_lifetime,
            )?;
        }
        output.write_all(b"}\n")
    }

    fn par_to_arg(pars: &str) -> String {
        pars.rsplit(':')
            .skip(1)
            .collect::<Vec<&str>>()
            .iter()
            .rev()
            .map(|s| s.rsplit(',').next().unwrap())
            .collect::<Vec<&str>>()
            .join(",")
    }
}
