// This file was generated by the generate.sh script.
// DO NOT EDIT THIS FILE MANUALLY!

use codespan_reporting::files::SimpleFile;
use codespan_reporting::term::termcolor::NoColor;
use codespan_reporting::term::{self, DisplayStyle};
use lelwel::frontend::parser::{Parser, Token, TokenStream};
use lelwel::frontend::sema::SemanticPass;
use lelwel::frontend::symbols::StringInterner;
use logos::Logos;
use std::io::BufWriter;

fn gen_diags(input: &str) -> String {
    let content = std::fs::read_to_string(input).unwrap();
    let mut tokens = TokenStream::new(Token::lexer(&content), input);
    let file = SimpleFile::new(input, &content);
    let mut diags = vec![];
    let mut interner = StringInterner::new();
    if let Some(mut module) = Parser::parse(&mut tokens, &mut diags, &mut interner) {
        SemanticPass::run(&mut module, &mut diags);
    }
    let mut writer = NoColor::new(BufWriter::new(Vec::new()));
    let config = codespan_reporting::term::Config {
        display_style: DisplayStyle::Short,
        ..Default::default()
    };
    for diag in diags {
        term::emit(&mut writer, &config, &file, &diag).unwrap();
    }
    std::str::from_utf8(writer.get_ref().buffer())
        .unwrap()
        .to_string()
}

#[test]
#[rustfmt::skip]
fn calc() {
    let diags = gen_diags("tests/frontend/calc.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn empty() {
    let diags = gen_diags("tests/frontend/empty.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "error[E010]: missing start rule");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn error_syntax() {
    let diags = gen_diags("tests/frontend/error_syntax.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/error_syntax.llw:6:3: error[E003]: multiple error handlers in alternation");
    assert_eq!(lines.next().unwrap(), "tests/frontend/error_syntax.llw:19:5: error[E001]: invalid error handler position");
    assert_eq!(lines.next().unwrap(), "tests/frontend/error_syntax.llw:24:3: error[E001]: invalid error handler position");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn expected_action() {
    let diags = gen_diags("tests/frontend/expected_action.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_action.llw:2:21: error[E007]: invalid action number");
    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_action.llw:2:24: error[E007]: invalid action number");
    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_action.llw:2:27: error[E007]: invalid action number");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn expected_error_handler() {
    let diags = gen_diags("tests/frontend/expected_error_handler.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_error_handler.llw:4:10: warning: use of undefined error handler");
    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_error_handler.llw:4:10: error[E007]: invalid error handler number");
    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_error_handler.llw:4:26: error[E007]: invalid error handler number");
    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_error_handler.llw:4:30: error[E007]: invalid error handler number");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn expected_predicate() {
    let diags = gen_diags("tests/frontend/expected_predicate.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_predicate.llw:4:3: warning: use of undefined predicate");
    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_predicate.llw:4:3: error[E007]: invalid predicate number");
    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_predicate.llw:9:3: error[E007]: invalid predicate number");
    assert_eq!(lines.next().unwrap(), "tests/frontend/expected_predicate.llw:10:3: error[E007]: invalid predicate number");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn invalid_lang() {
    let diags = gen_diags("tests/frontend/invalid_lang.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/invalid_lang.llw:1:10: error: invalid syntax, expected one of: <semantic action>, <code segment>, ':', <error handler>, <semantic predicate>");
    assert_eq!(lines.next().unwrap(), "tests/frontend/invalid_lang.llw:1:17: error: invalid syntax, expected one of: <semantic action>, <code segment>, ':', <error handler>, <semantic predicate>");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn invalid_token() {
    let diags = gen_diags("tests/frontend/invalid_token.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/invalid_token.llw:4:5: error: invalid token");
    assert_eq!(lines.next().unwrap(), "tests/frontend/invalid_token.llw:4:7: error: invalid token");
    assert_eq!(lines.next().unwrap(), "tests/frontend/invalid_token.llw:4:8: error: invalid token");
    assert_eq!(lines.next().unwrap(), "tests/frontend/invalid_token.llw:4:9: error: invalid token");
    assert_eq!(lines.next().unwrap(), "tests/frontend/invalid_token.llw:4:11: error: invalid token");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn json() {
    let diags = gen_diags("tests/frontend/json.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn left_recursive() {
    let diags = gen_diags("tests/frontend/left_recursive.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/left_recursive.llw:2:3: error[E015]: no tokens consumed");
    assert_eq!(lines.next().unwrap(), "tests/frontend/left_recursive.llw:6:3: error[E015]: no tokens consumed");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn lelwel() {
    let diags = gen_diags("tests/frontend/lelwel.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn ll1_conflict() {
    let diags = gen_diags("tests/frontend/ll1_conflict.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/ll1_conflict.llw:4:4: error[E012]: LL(1) conflict in alternation");
    assert_eq!(lines.next().unwrap(), "tests/frontend/ll1_conflict.llw:5:4: error[E012]: LL(1) conflict in alternation");
    assert_eq!(lines.next().unwrap(), "tests/frontend/ll1_conflict.llw:6:3: error[E013]: LL(1) conflict in repetition");
    assert_eq!(lines.next().unwrap(), "tests/frontend/ll1_conflict.llw:7:3: error[E013]: LL(1) conflict in repetition");
    assert_eq!(lines.next().unwrap(), "tests/frontend/ll1_conflict.llw:8:3: error[E014]: LL(1) conflict in option");
    assert_eq!(lines.next().unwrap(), "tests/frontend/ll1_conflict.llw:19:3: error[E014]: LL(1) conflict in option");
    assert_eq!(lines.next().unwrap(), "tests/frontend/ll1_conflict.llw:30:3: error[E012]: LL(1) conflict in alternation");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn lowercase_token() {
    let diags = gen_diags("tests/frontend/lowercase_token.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/lowercase_token.llw:1:7: error[E009]: token name starts with lower case letter");
    assert_eq!(lines.next().unwrap(), "tests/frontend/lowercase_token.llw:1:9: error[E009]: token name starts with lower case letter");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn predef_token() {
    let diags = gen_diags("tests/frontend/predef_token.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/predef_token.llw:1:7: error[E011]: use of predefined token name");
    assert_eq!(lines.next().unwrap(), "tests/frontend/predef_token.llw:4:11: error[E005]: use of undefined token `EOF`");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn predicate_position() {
    let diags = gen_diags("tests/frontend/predicate_position.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/predicate_position.llw:4:3: error[E002]: invalid predicate position");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn recursion_depth() {
    let diags = gen_diags("tests/frontend/recursion_depth.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/recursion_depth.llw:2:34: error: exceeded recursion depth limit");
    assert_eq!(lines.next().unwrap(), "error[E010]: missing start rule");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn redefinition() {
    let diags = gen_diags("tests/frontend/redefinition.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/redefinition.llw:1:9: error[E006]: redefinition of token `A`");
    assert_eq!(lines.next().unwrap(), "tests/frontend/redefinition.llw:1:13: error[E006]: redefinition of token `B`");
    assert_eq!(lines.next().unwrap(), "tests/frontend/redefinition.llw:9:1: error[E006]: redefinition of rule `a`");
    assert_eq!(lines.next().unwrap(), "tests/frontend/redefinition.llw:14:1: error[E006]: redefinition of rule `b`");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn syntax_error() {
    let diags = gen_diags("tests/frontend/syntax_error.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/syntax_error.llw:2:1: error: invalid syntax, expected one of: <code segment>, '=', <identifier>, ';'");
    assert_eq!(lines.next().unwrap(), "tests/frontend/syntax_error.llw:6:1: error: invalid syntax, expected: ')'");
    assert_eq!(lines.next().unwrap(), "tests/frontend/syntax_error.llw:11:2: error: invalid syntax, expected one of: <semantic action>, <error handler>, <identifier>, '[', '(', '|', '+', <semantic predicate>, ']', ')', ';', '*', <string literal>");
    assert_eq!(lines.next().unwrap(), "tests/frontend/syntax_error.llw:5:8: error[E005]: use of undefined token `C`");
    assert_eq!(lines.next().unwrap(), "tests/frontend/syntax_error.llw:11:1: error[E005]: use of undefined rule `b`");
    assert_eq!(lines.next().unwrap(), "tests/frontend/syntax_error.llw:16:3: error[E005]: use of undefined token `C`");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn undefined_action() {
    let diags = gen_diags("tests/frontend/undefined_action.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_action.llw:2:3: warning: use of undefined action");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_action.llw:2:11: warning: use of undefined action");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_action.llw:6:3: warning: use of undefined action");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_action.llw:6:6: warning: use of undefined action");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn undefined_error_handler() {
    let diags = gen_diags("tests/frontend/undefined_error_handler.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_error_handler.llw:6:4: error[E001]: invalid error handler position");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_error_handler.llw:2:11: warning: use of undefined error handler");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_error_handler.llw:2:15: warning: use of undefined error handler");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_error_handler.llw:6:5: warning: use of undefined error handler");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_error_handler.llw:6:13: warning: use of undefined error handler");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn undefined() {
    let diags = gen_diags("tests/frontend/undefined.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined.llw:2:3: error[E005]: use of undefined token `A`");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined.llw:2:5: error[E005]: use of undefined rule `b`");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined.llw:2:7: error[E005]: use of undefined token `C`");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined.llw:2:9: error[E005]: use of undefined rule `d`");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn undefined_predicate() {
    let diags = gen_diags("tests/frontend/undefined_predicate.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_predicate.llw:5:3: warning: use of undefined predicate");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_predicate.llw:6:3: warning: use of undefined predicate");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_predicate.llw:10:3: warning: use of undefined predicate");
    assert_eq!(lines.next().unwrap(), "tests/frontend/undefined_predicate.llw:12:3: warning: use of undefined predicate");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn unused_element() {
    let diags = gen_diags("tests/frontend/unused_element.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/unused_element.llw:1:7: warning: unused element");
    assert_eq!(lines.next().unwrap(), "tests/frontend/unused_element.llw:1:11: warning: unused element");
    assert_eq!(lines.next().unwrap(), "tests/frontend/unused_element.llw:7:1: warning: unused element");
    assert_eq!(lines.next().unwrap(), "tests/frontend/unused_element.llw:11:1: warning: unused element");
    assert_eq!(lines.next().unwrap(), "tests/frontend/unused_element.llw:21:1: warning: unused element");
    assert_eq!(lines.next(), None);
}

#[test]
#[rustfmt::skip]
fn uppercase_rule() {
    let diags = gen_diags("tests/frontend/uppercase_rule.llw");
    let mut lines = diags.lines();

    assert_eq!(lines.next().unwrap(), "tests/frontend/uppercase_rule.llw:4:1: error[E008]: rule name starts with upper case letter");
    assert_eq!(lines.next().unwrap(), "tests/frontend/uppercase_rule.llw:7:1: error[E008]: rule name starts with upper case letter");
    assert_eq!(lines.next(), None);
}
